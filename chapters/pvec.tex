\chapter{Persistent vectors in Rust}
\label{chapter:persistent-vectors-in-rust}

The purpose of this chapter is bifold: to present the \pvecrs{} project and to discuss its unique design traits in the context of Rust. First, we will take a look at the project structure, the types offered by the library, and how it can be configured.

Then, we will take a look at the design and optimizations of the persistent vector implementation in Rust and their specifics:

\begin{itemize}
    \item First, we will take a look at the memory layout of \rrbtree{} and how it supports the implementation of cloning and path copying.
    \item Then, transience and dynamic representation optimizations will be introduced in the context of Rust's ownership and borrowing rules.
    \item At last, we will talk about thread-safety and the requirements for sharing objects between threads.
\end{itemize}

\section{Presentation of the project}
The \pvecrs{} project consists of three crates:
\begin{itemize}
    \item The library crate itself with the persistent vector implementation.
    \item \crate{web-vis}: a web application for visualization of the data structure in the browser.
    \item \crate{benches-mem}: The benchmarking application for measuring the memory footprint of persistent vectors. Its usage is described in detail in \Cref{chapter:methodology}.
\end{itemize}

The structure of the library is demonstrated in \Cref{lst:library-structure}. The \dir{pvec-rs} directory is the root of the library crate. The definition of \rrbtree{}, \rbvec{}, \rrbvec{}, and \pvec{} are all located under the \dir{src} folder. The \dir{benches} and \dir{tests} folders are for runtime benchmarks and integration tests correspondingly.

\begin{figure}[!htbp]
    \definecolor{folderbg}{RGB}{124, 166, 198}
    \definecolor{folderborder}{RGB}{110, 144, 169}

    \def\Size{4pt}
    \tikzset{
        folder/.pic={
            \filldraw[draw=folderborder, top color=folderbg!50, bottom color=folderbg]
                (-1.05*\Size, 0.2\Size+5pt) rectangle ++(.75*\Size, -0.2\Size-5pt);
            \filldraw[draw=folderborder, top color=folderbg!50, bottom color=folderbg]
                (-1.15*\Size, -\Size) rectangle (1.15*\Size, \Size);
        },
        file/.pic={
            \filldraw[draw=folderborder, top color=folderbg!5, bottom color=folderbg!10]
                (-\Size, .4*\Size+5pt) coordinate(a) |- (\Size, -1.2*\Size) coordinate(b) -- ++(0, 1.6*\Size) coordinate(c) -- ++(-5pt, 5pt) coordinate(d) -- cycle(d) |- (c);
        },
    }

    \centering
    \begin{forest}
        for tree={
            font=\ttfamily,
            grow'=0,
            child anchor=west,
            parent anchor=south,
            anchor=west,
            calign=first,
            inner xsep=8pt,
            edge path={
            \noexpand\path [draw, \forestoption{edge}]
                (!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
            },
            file/.style={
                edge path={
                \noexpand\path [draw, \forestoption{edge}]
                    (!u.south west) +(7.5pt, 0) |- (.child anchor) pic {file} \forestoption{edge label};
                },
            },
            before typesetting nodes={
            if n=1
                {insert before={[,phantom]}}
                {},
            },
            fit=band,
            before computing xy={l=15pt},
        }
        [
            [pvec-rs
                [benches, label=right:- runtime benchmarks
                ]
                [benches-mem, label=right:- memory benchmarks
                ]
                [src, label=right:- the library source code
                ]
                [tests, label=right:- integration tests
                ]
                [web-vis, label=right:- visualization crate
                ]
                [Cargo.toml, file, label=right:- package manifest
                ]
            ]
        ]
        \end{forest}

    \caption{The folder structure of \pvecrs{}}
    \label{lst:library-structure}
\end{figure}

\subsection{Configurability}
The \pvecrs{} project can be configured using the feature flags described in \Cref{tab:feature-flags}.

\begin{table}[H]

    \centering
    \begin{tabular} { |p{34mm}|p{96mm}| }
        \hline
        \rust{small_branch} & Sets the branching factor used by \rrbtree{} to 4. \\ \hline
        \rust{arc} & Selecting the thread-safe version of the \rc{} pointer. \\ \hline
        \rust{rayon_iter} & if specified together with the \rust{arc} flag, provides the parallel iterator implementation for Rayon. \\ \hline
        \rust{serde_serializer} & \pvecrs{} provides the JSON\footnote{JSON or JavaScript Object Notation is an open standard file and data interchange format.} serializer if specified. \\ \hline
    \end{tabular}

    \label{tab:feature-flags}
    \caption{Feature flags for the library configuration}
\end{table}

By default, the branching factor used by the tree-based vector types is equal to 32. If \rust{small_branch} flag is specified, the branching factor will be 4. This flag is useful for integration testing to reveal issues with the re-balancing algorithm earlier as the tree ends-up being significantly taller compared to using the branching factor of 32.

To compile persistent vectors for use in multi-threaded environment Rust requires to implement \rust{Send} and \rust{Sync} traits. When compiled with the \rust{arc} feature flag, those traits will be automatically implemented for all vector types enabling multi-threaded use cases.

To access the \rayon{}'s parallel iterator implementations, the library user has to use both the \rust{arc} and \rust{rayon_iter} feature flags when including the library.

\subsection{The library APIs}
The \pvecrs{} project is the Rust library crate that offers several persistent vector implementations listed in \Cref{tab:vec-implementations}.

\begin{table}[!htbp]

    \centering
    \begin{tabular} { |p{18mm}|p{112mm}| }
        \hline
        \rbvec{} & A persistent vector based on the balanced \rrbtree{}. \\ \hline
        \rrbvec{} & The \rrbtree{}-based persistent vector implementation with efficient concatenation and splitting. Its underlying \rrbtree{} instance remains balanced unless concatenated or splitted, after which it becomes relaxed. \\ \hline
        \pvec{} & A vector that starts as the standard and switches to \rrbvec{} when cloned. \\ \hline
    \end{tabular}

    \label{tab:vec-implementations}
    \caption{Vector implementations provided by \pvecrs{}}
\end{table}

\rbvec{} and \rrbvec{} are based on \rrbtree{}. Both types implement the \emph{tail}\footnote{See \Cref{sec:tail-optimization} for details on the \emph{tail} optimization.} optimization and offer effectively constant \rust{push}, \rust{pop}, \rust{get}, and \rust{get_mut} operations, with the difference that \rrbvec{} offers efficient \rust{append} and \rust{split_off}. \pvec{}, on the other hand, inherits performance properties of the underlying representation that is either \stdvec{} or \rrbvec{}.

\begin{table}[!ht]
    \newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

    \centering
    \footnotesize
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular} { p{74mm} P{8mm} P{20mm} P{20mm} }

        \textbf{A vector function} & \stdvec{} & \rbvec{} & \rrbvec{} \\ \hline

        \rust{fn push(&mut self, e: T)} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$log_m(n)$}  & \multirow{2}{*}{$log_m(n)$} \\
        Appends an element to the back of a collection & & & \\ \hdashline

        \rust{fn pop(&mut self) -> Option<T>} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$m \cdot log_m(n)$}  & \multirow{2}{*}{$m \cdot log_m(n)$} \\
        Returns the last removed value or \rust{None} if vector is empty. & & & \\ \hdashline

        \rust{fn get(&self, i: usize) -> Option<&T>} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$log_m(n)$}  & \multirow{2}{*}{$log_m(n)$} \\
        Returns a reference to an element. & & & \\ \hdashline

        \rust{fn get_mut(&mut self, i: usize) -> Option<&mut T>} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$m \cdot log_m(n)$}  & \multirow{2}{*}{$m \cdot log_m(n)$} \\
        Returns a mutable reference to an element. & & & \\ \hdashline

        \rust{fn append(&mut self, v: &mut Vec<T>)} & \multirow{2}{*}{$n$} & \multirow{2}{*}{$n$}  & \multirow{2}{*}{$m^2 \cdot log_m(n)$} \\
        Concatenates two vectors by moving all values of \rust{v} into \rust{self}, leaving other empty. & & & \\ \hdashline

        \rust{fn split_off(&mut self, at: usize) -> Vec<T>} & \multirow{2}{*}{$n$} & \multirow{2}{*}{$n$}  & \multirow{2}{*}{$m \cdot log_m(n)$} \\
        Splits the collection into two at the given index. & & & \\ \hdashline

        \rust{fn len(&self) -> usize} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$C$}  & \multirow{2}{*}{$C$} \\
        Returns the number of elements in the vector. & & & \\ \hdashline

        \rust{fn is_empty(&self) -> bool} & \multirow{2}{*}{$C$} & \multirow{2}{*}{$C$}  & \multirow{2}{*}{$C$} \\
        Returns \rust{true} if the vector contains no elements. & & & \\ \hdashline

        \rust{fn into_iter(self) -> Iterator} & \multirow{2}{*}{$n$} & \multirow{2}{*}{$n$}  & \multirow{2}{*}{$n$} \\
        Creates an iterator from \rust{self}. & & & \\ \hdashline

        \rust{fn into_par_iter(self) -> IntoParallelIterator} & \multirow{2}{*}{$n$} & \multirow{2}{*}{$n$}  & \multirow{2}{*}{$n$} \\
        Converts \rust{self} into a parallel iterator. Note, it requires the \rust{arc} and \rust{rayon_iter} feature flags. & & & \\ \hline
    \end{tabular}

    \label{tab:vector-apis}
    \caption{A table of methods supported by persistent vectors}
\end{table}

All vectors provide methods with identical method signatures with the difference in how much each operation costs, and how they are implemented. \Cref{tab:vector-apis} lists available functions and their complexity.

Complexity of operations in \Cref{tab:vector-apis} is expressed using the Big O notation. The \bigo{1} value was substituted by $C$ for brevity.

The characteristics of the \rbvec{} and \rrbvec{} operations are effectively constant given that $m = 32$, and the input size $n$ is bound by the maximum capacity of the 32-bit integer resulting in $log_m(n) < 7$.

\paragraph{Core and bulk operations}
Operations that interact with a single value, such as push, pop, and get, will be referred to as \emph{\textbf{core}} operations. Operations that work with multiple values will be referred to as \emph{\textbf{bulk}} operations, such as append, split, and iterators.

\subsubsection*{Iterators}
Iterators\footnote{\url{https://doc.rust-lang.org/std/iter/trait.Iterator.html}} are a powerful alternative to \emph{for} loops that offer a variety of operators for processing collection elements.

The foundation of iterators for \pvecrs{} vectors is the \rrbtree{} iterator implementation that presents a tree as a collection of leaf nodes. Instead of reading individual values using the radix search, the tree iterator returns the entire leaf node. Vector iterators cache the node and read values from it until it is exhausted, after which they request the next node from the tree iterator, minimizing the number of the tree-traversals and improving performance. This optimization can be thought of as the generalization of the tail optimization described in \Cref{sec:tail-optimization}.

\subsubsection*{Parallel iterators}
Parallel iterators process collection elements on multiple threads. The parallel iterator implementation for \pvecrs{} is based on the data parallelism framework \rayon{}, and can be enabled using the \rust{arc} and \rust{rayon_iter} feature flags. Compared to sequential iterators, the parallel ones do not guarantee the deterministic order of processing values.

The library documentation can be found at: \url{https://docs.rs/pvec/}.

\section{Memory layout}
To define persistent vectors in Rust, we first need to understand how different parts of the data structure can be represented in the computer memory, and which Rust constructs are the most suitable for this purpose.

The foundation of a confluently persistent vector is \rrbtree{}, with additional fields such as a tail, size, and height. \rrbtree{} consists of infinitely nested nodes, which form a directed acyclic graph\footnote{A directed acyclic graph is a data structure that consists of nodes connected with directed edges, in which moving from node to node by following edges will never lead to the same node again.} in memory.

As the persistent vector can be arbitrarily large, the Rust compiler is not able to measure its size during compilation. Hence, the memory allocation on the stack is not possible without additional constraints, such as the fixed vector capacity.

In fact, the Rust compiler will abort the compilation if a \emph{recursive data type}\footnote{\url{https://doc.rust-lang.org/book/ch15-01-box.html\#enabling-recursive-types-with-boxes}} definition is encountered. A recursive data type is a type that contains itself, such as a tree node. The solution is to use dynamic memory allocation instead of static. Rust offers a particular type of pointers for this purpose known as smart pointers, such as \boxptr{}, \rc{}, etc.

As \rrbtree{} employs structural sharing, several tree instances might point to the same sub-tree. In other words, one node can be referenced by several parent nodes simultaneously. Even though \boxptr{} enables recursive types, it does not allow shared ownership of the underlying value. A smart pointer that supports a notion of shared ownership is known as \rc{} or reference counting pointer.

\subsection{Reference counting pointers}
In a nutshell, a reference counting pointer allows shared ownership of the object wrapped into it. Every time a potential owner needs a reference to the value, the pointer itself is cloned instead of the underlying object. The reference count is incremented on each clone, and decremented when a pointer goes out of the scope. If the reference count reaches zero, the underlying value is destroyed.

\subsubsection*{Copy-on-write semantics}
Rust’s \rc{} conforms to the ownership and borrowing rules that are enforced during runtime rather than compile-time. It allows shared immutable access to the value as well as regular reference does, and permits unique mutable access only if other references do not exist.

The \mintinline{rust}{Rc::make_mut} method allows us to safely acquire a mutable pointer to the value regardless of the reference count. If there are no other pointers to the value, then \mintinline{rust}{Rc::make_mut} immediately returns a mutable reference. Otherwise, it clones the inner value to a new allocation to ensure unique ownership and then returns a reference to it. This mechanism will be referred to as conditional \emph{copy-on-write} behavior.

\subsubsection*{Path copying}
When updating the tree, the path leading from the root node to the affected leaf is copied to preserve the original tree from changes. The copy-on-write semantics of \rc{} is the foundation for the path copying algorithm implementation in \rrbtree{}.

Rust permits updating objects only through mutable references. To update a value in the tree, one has to acquire a mutable reference to each node that forms a path to the value. Since nodes are decorated with \rc{} pointer, a safe way to acquire a mutable reference is by calling the \mintinline{rust}{Rc::make_mut} method. If the tree has been cloned prior to the update, this call will copy each node while descending from the root to the leaf node, effectively performing \emph{path copying}.

\subsection{Structures, enumerations and cache locality}
With the knowledge of how \rc{} helps to manage the memory and its semantics we can move on to the definition of the \rrbtree{} node using the following Rust constructs:
\begin{itemize}
    \item Structures or \emph{structs} are used to define a custom data type that lets you package together multiple related values \ref{sec:enums-structs-traits}.
    \item Enumerations or \emph{enums} allow to define a type by enumerating its possible \emph{variants} \ref{sec:enums-structs-traits}.
\end{itemize}

Conceptually, the \rrbtree{} consists of three node types: a balanced branch, a relaxed branch and a leaf. Depending on the tree level, branching nodes reference either other branching nodes or leaves. Thus, the node definition has to be generic over the child node type.

Rust forbids inheritance in structs. It does, however, provide alternative ways of defining data types that are conceptually related: enumerations and \emph{trait objects}\footnote{\url{https://doc.rust-lang.org/book/ch17-02-trait-objects.html}}.

Trait objects are objects that share common behavior by implementing the same interface. The main advantage of trait objects is their extensibility. Enums, on the other hand, cannot be extended with more variants outside of their declaration. Since tree nodes are an implementation detail of persistent vectors and are not expected to be extended, enums were favored over trait objects.

Each enum variant can have a different set of fields. Hence, the enum size is capped by its largest variant to guarantee that all variants can be used interchangeably.

\subsubsection*{Defining \rrbtree{} node in Rust}

We can finally bring everything together using structs and enums in combination with \rc{} to define the \rrbtree{} node. \Cref{fig:rrbtree-node} presents the structure as it is in the library.

\begin{listing}[!ht]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{rust}
        #[cfg(feature = "arc")]
        type SharedPtr<T> = Arc<T>;

        #[cfg(not(feature = "arc"))]
        type SharedPtr<T> = Rc<T>;
        // ^ SharedPtr<T> is a type alias that is assigned either Arc<T> or
        // Rc<T> depending on the thread-safety requirements and configuration.

        enum Node<T> {
            RelaxedBranch(SharedPtr<RelaxedBranch<T>>),
            Branch(SharedPtr<Branch<T>>),
            Leaf(SharedPtr<Leaf<T>>),
        }

        struct RelaxedBranch<T> {
            children: [Option<Node<T>>; BRANCH_FACTOR],
            sizes: [Option<usize>; BRANCH_FACTOR],
            len: usize,
        }

        struct Branch<T> {
            children: [Option<Node<T>>; BRANCH_FACTOR],
            len: usize,
        }

        struct Leaf<T> {
            elements: [Option<T>; BRANCH_FACTOR],
            len: usize,
        }
    \end{minted}

    \caption{Definition of the \rrbtree{} node}
    \label{fig:rrbtree-node}
\end{listing}

Each node type has received its own struct definition. An eagle eyed reader will notice that the \type{Node} enum in \Cref{fig:rrbtree-node} could have been declared in a more concise way by having the node fields defined directly within the variant. Even though it seems to be a more intuitive approach, it comes at a hidden cost.

\paragraph{The enum size and the cache locality}

\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}[
        font=\ttfamily,
        nodes={
            draw,
            anchor=center,
            minimum height=8mm,
            text depth=.5ex,
            text height=2ex
        },
    ]
        \node[draw, fill=blue!20, anchor=center, minimum width=14mm, minimum height=8mm, inner sep=4pt] at (current page.north west) (rc) {ptr};
        \draw(rc.north) node[above, draw=none] {\mintinline{rust}{Rc<T>}};

        \matrix[inner sep=4pt] (rcptr) [below = 6mm of rc.south] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=26mm] {T}; \\
        };

        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (rcptr.north west) rectangle (rcptr.south east);
        \end{scope}

        \draw[->, shorten >= 4pt] (rc.south) to (rcptr.north);

        \matrix[draw=none, inner sep=4pt] (enum-var-1) [below=16mm of rcptr.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=24mm] {A}; &
            \node[fill=white, minimum width=16mm] {}; \\
        };
        \draw(enum-var-1.north) node[above, draw=none] {\mintinline{rust}{enum {A, B, C}}};

        \matrix[draw=none, inner sep=4pt] (enum-var-2) [below=0pt of enum-var-1.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=40mm] {B}; \\
        };
        \matrix[draw=none, inner sep=4pt] (enum-var-3) [below=0pt of enum-var-2.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=14mm] {C}; &
            \node[fill=white, minimum width=26mm] {}; \\
        };

        \node[draw, fill=blue!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] [right=12mm of rcptr.east] (legptr) {ptr};
        \draw(legptr.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=green!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] [below=6mm of legptr.south west, anchor=west] (legsize) {size};
        \draw(legsize.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=red!20, minimum width=20mm, minimum height=8mm, inner sep=4pt] [below=6mm of legsize.south west, anchor=west] (legt) {T};
        \draw(legt.east) node[right, draw=none] {User defined type};

        \node[draw, fill=yellow!40, minimum width=32mm, minimum height=8mm, inner sep=4pt] [below=6mm of legt.south west, anchor=west] (legalloc) {allocation};
        \draw(legalloc.east) node[right, draw=none] {Heap allocation};
    \end{tikzpicture}

    \caption{The memory layout of Rust containers}
    \label{fig:memory-layout-of-rust-containers}
\end{figure}

As illustrated\footnote{The illustration contains a subset of containers from the Rust container cheat sheet: \url{https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4}.} in \Cref{fig:memory-layout-of-rust-containers}, enumerations take up as much space as their largest variant. If the node fields were declared within the enum variants directly, the enum size would be equal to the size of \mintinline{rust}{RelaxedBranch}, resulting in the balanced tree reserving as much space as if it was relaxed.

The more space nodes use, the more expensive the memory allocations are. Also, bigger nodes are more likely to not fit into the CPU cache lines, negatively impacting the performance even more.

To avoid the unnecessarily large memory footprint of the \mintinline{rust}{Node} enum, the decision was made to extract the node fields into structs as demonstrated in the \Cref{fig:rrbtree-node}. By wrapping the struct instances into a smart pointer such as \rc{}, we explicitly move the allocation of the node to the heap.

The size of the \rc{} pointer is independent of the type it encapsulates. Hence, the size of the \mintinline{rust}{Node} enum boils down to the size of the enum tag, the weak and strong reference count fields of \rc{}, and the actual pointer to the heap.

This, in turn, means that the \mintinline{rust}{Node} enum variants will be equally sized, taking as little space as possible. When compiling the library for a machine with the 64-bit CPU architecture, the enum size is 16 bytes, where 8 bytes are reserved for the enum tag, and 8 bytes for the reference-counted pointer.

\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}[
        font=\ttfamily,
        nodes={
            draw,
            anchor=center,
            minimum height=8mm,
            text depth=.5ex,
            text height=2ex
        },
    ]
        \node[draw, fill=blue!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] at (current page.north east) (legptr) {ptr};
        \draw(legptr.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=green!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] [below=6mm of legptr.south west, anchor=west] (legsize) {size};
        \draw(legsize.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=red!20, minimum width=20mm, minimum height=8mm, inner sep=4pt] [below=6mm of legsize.south west, anchor=west] (legt) {T};
        \draw(legt.east) node[right, draw=none] {User defined type};

        \node[draw, fill=yellow!40, minimum width=32mm, minimum height=8mm, inner sep=4pt] [below=6mm of legt.south west, anchor=west] (legalloc) {allocation};
        \draw(legalloc.east) node[right, draw=none] {Heap allocation};

        \matrix[draw=none, inner sep=4pt] [below left=4mm and 8mm of legalloc.west] (enum-var-relaxed-branch) {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=blue!20, minimum width=48mm] {\mintinline{rust}{Rc<RelaxedBranch<T>>}}; \\
        };
        \draw(enum-var-relaxed-branch.north) node[above, draw=none] {\mintinline{rust}{enum Node}};

        \matrix[draw=none, inner sep=4pt] (enum-var-branch) [below=0pt of enum-var-relaxed-branch.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=blue!20, minimum width=48mm] {\mintinline{rust}{Rc<Branch<T>>}}; \\
        };
        \matrix[draw=none, inner sep=4pt] (enum-var-leaf) [below=0pt of enum-var-branch.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=blue!20, minimum width=48mm] {\mintinline{rust}{Rc<Leaf<T>>}}; \\
        };

        \matrix[draw=none, inner sep=4pt] (relaxed-branch) [below right=12mm and 2mm of enum-var-leaf.south] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=22mm] {children}; &
            \node[fill=red!20, minimum width=14mm] {sizes}; &
            \node[fill=red!20, minimum width=14mm] {len}; \\
        };
        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (relaxed-branch.north west) rectangle (relaxed-branch.south east);
        \end{scope}

        \matrix[draw=none, inner sep=4pt] (branch) [below=8mm of relaxed-branch.south west, anchor=west] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=22mm] {children}; &
            \node[fill=red!20, minimum width=14mm] {len}; \\
        };
        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (branch.north west) rectangle (branch.south east);
        \end{scope}

        \matrix[draw=none, inner sep=4pt] (leaf) [below=8mm of branch.south west, anchor=west] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=22mm] {elements}; &
            \node[fill=red!20, minimum width=14mm] {len}; \\
        };
        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (leaf.north west) rectangle (leaf.south east);
        \end{scope}

        \draw[->, shorten >= 4pt, out=0, in=90] (enum-var-relaxed-branch.east) to (relaxed-branch.north);
        \draw[->, shorten >= 4pt, out=0, in=180, looseness=2] (enum-var-branch.east) to (branch.west);
        \draw[->, shorten >= 4pt, out=0, in=0, looseness=2] (enum-var-leaf.east) to (leaf.east);
    \end{tikzpicture}

    \caption{The memory layout of the \rrbtree{} node}
    \label{fig:memory-layout-of-rrbtree-node}
\end{figure}

\Cref{fig:memory-layout-of-rrbtree-node} visualizes how the enum and struct definitions of the \rrbtree{} node are arranged in memory.

\section{Pay only for the features you use}
The \pvecrs{} project draws inspiration from one of the Rust key design traits --- zero-cost abstractions. In this chapter, we will look at how \pvec{} follows that design principle by offering optimizations such as transience and dynamic representation, without sacrificing Rust's safety guarantees.

\subsection{Transience as the language feature}
Popular persistent data structure libraries, such as \emph{immutable-js}\footnote{\url{https://immutable-js.github.io/immutable-js/}}, or collections in the standard library of \emph{Scala}\footnote{\url{https://docs.scala-lang.org/overviews/parallel-collections/overview.html}}, often provide an interface that is very different from the interface of the ephemeral data structures.

As demonstrated in \Cref{lst:conventional-interface}, instead of updating the vector in-place, the operation returns a new instance that contains the change. When a collection is set up like that, the library can guarantee that the original vector will stay unmodified, eliminating the whole class of bugs such as race conditions.

This, in turn, means that every modification will cause a copy. For example, in a pure function where vector processing is scoped strictly to the function body, there is no risk of introducing a race condition, and therefore, no need to create new copies. The solution to this problem was first introduced in the \emph{Clojure} programming language in the shape of \emph{transient} data types. A \emph{transient}, persistent vector is a vector that is persistent but can be updated in-place without generating unnecessary copies \ref{sec:transience}.

Rust's compiler, however, eliminates race conditions by forbidding simultaneous mutation of value by enforcing ownership and borrowing rules. The ownership rule essentially means that an object can be owned only by a single entity at a time. Borrowing rules state that any number of immutable references can be created given that there is no \emph{mutable} references existing. Further than that, if a mutable reference exists, Rust ensures that it is the only \emph{unique} reference.

This leads us to a question of whether the traditional persistent collection interface is needed in Rust. The short answer is no because the compiler protects developers from common mistakes. Nicholas Matsakis, the lead engineer of the Rust's compiler, elaborated why in Rust persistent vectors can have an ordinary interface in his blog\footnote{\url{http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/}}.

\subsubsection*{Unique access as transience}
Unique access as a term stems from the fact that in Rust, a mutable reference to an object must be \emph{unique}. By leveraging this guarantee, persistent vectors in Rust can have a conventional mutable interface without sacrificing safety.

\begin{listing}[!ht]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{rust}
        fn main() {
            let vec_1 = immutable_api(42);

            let vec_2 = mutable_api(42);
            let mut cloned_vec_2 = vec_2.clone();
            // ^ increments the reference count, but no copying yet

            cloned_vec_2.push(34);
            // ^ an attempt to update the tree with rc > 1
            // triggers the path copying algorithm
        }

        fn immutable_api(size: usize) -> PersistentVec<usize> {
            let mut vec = PersistentVec::new();
            for i in 0..size {
                vec = vec.push(i); // <- creates a new instance on every push
            }
            vec
        }

        fn mutable_api(size: usize) -> PersistentVec<usize> {
            let mut vec = PersistentVec::new();
            for i in 0..size {
                vec.push(i); // <- new instances are not created
            }
            vec
        }
    \end{minted}

    \caption{The persistent and conventional interfaces of vectors}
    \label{lst:conventional-interface}
\end{listing}

As demonstrated in \rust{mutable_api} in \Cref{lst:conventional-interface}, the conventional interface allows to update the vector in-place without creating copies.

This is possible because of the conditional \emph{copy-on-write} semantics of \rc{} pointers that are used at the core of \rrbtree{}. If the reference count is at most one, \rust{Rc::make_mut} will not copy the underlying value but rather update it in-place.

When cloned on line 5, the reference count of the root node of the underlying \rrbtree{} is incremented by one. The path copying algorithm is executed only when trying to mutate the cloned instance on line 8, leaving the original \rust{vec_2} unmodified.

Path copying that is delayed to the first update means that the clone operation is effectively free in cases when a vector is cloned and shared for read-only purposes.

\paragraph{Transience in Clojure is different}
Transience in Clojure\footnote{\url{https://clojure.org/reference/transients}} is not identical to unique access based optimization in Rust, and these are the main differences:

\begin{itemize}
    \item In Clojure, transient vectors are confined to the thread they are created on. Therefore, they cannot be modified on another thread. Persistent vectors in Rust can be safely moved between threads as long as the ownership and borrowing rules are followed.
    \item Calling any methods on a transient vector after it transitions back to persistent is prohibited and will cause an exception in Clojure. In Rust, there are no special restrictions imposed on vectors.
    \item In order to initialize a transient collection in Clojure, one has to use special syntax such as the \mintinline{clojure}{transient} function, or \mintinline{clojure}{persistent!} to convert a transient instance back to persistent.
\end{itemize}

\subsection{Dynamic representation}
A unique property of \pvec{} is that it features an interface identical to the standard vector, contrary to the conventional persistent interface that is significantly different.

If two vector types have identical interfaces, in theory, they can be used interchangeably without any additional changes made to the program. Hence, it becomes possible to dynamically choose a vector type depending on the context and performance requirements.

The dynamic representation explores this idea by using both the standard and tree-based vectors to ensure the best possible performance, depending on the use case.

\subsubsection*{Deciding when to switch the representation}
The standard vector is very fast in almost all operations due to its efficient, hardware friendly design. Exceptions are the operations that rely on copying, such as concat, split, and clone. The tree-based vector, on the other hand, offers effectively \bigo{1} clones and good all-around performance.

To take the best of both worlds, a vector can start as the standard vector and when it is cloned, it will be transformed into the tree-based one. Essentially, by switching the representation only when cloning, we offset the cost of using trees until they are beneficial\footnote{Nicholas Matsakis proposed a variation of this idea as future work in his blog: \url{http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/}}. This optimization fits into the overall "Pay only for the features you use" idea, as it prevents the user from paying the abstraction cost until it is used.

\subsubsection*{Switching the representation}
Essentially, a persistent vector type -- \pvec{}, can be backed by two different vector types at runtime. It starts as \stdvec{}, and then switches to the \rrbvec{} on the first clone. The process of switching from one vector type to another is called \emph{spilling}, as it maps a contiguous chunk of memory into smaller pieces that are used as leaf nodes to build \rrbvec{}.

\begin{listing}[H]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{rust}
        struct PVec<T>(Representation<T>);

        enum Representation<T> {
            Flat(Vec<T>),
            Tree(RrbVec<T>),
        }
    \end{minted}

    \caption{Memory layout of \pvec{}}
    \label{lst:pvec-memory-representation}
\end{listing}

\pvec{} has two representations: \type{Flat} that is using \stdvec{}, and \type{Tree} that is backed by \rrbvec{}. The initial capacity of both representations is equal to the branching factor of 32 by default.

Spilling happens by converting the flat vector into an iterator of sub-arrays that are 32 elements wide and pushing them directly onto \rrbtree{} as leaf nodes. If the last chunk is smaller than 32, then it will be used as the tail for the new \rrbvec{}. See \Cref{fig:switching-representations} that visualizes the transition.

One could have considered splitting up the original vector into chunks and reusing them instead of copying. Unfortunately, heap allocators do not have a mechanism for safely splitting an existing allocation into smaller ones. The Rust's allocator interface\footnote{\url{https://doc.rust-lang.org/std/alloc/struct.System.html}} reflects this limitation by exposing functions that allow allocating and freeing memory but no subdivision of existing allocations.

Additionally, the cost of spilling needs to be paid only once, and will be amortized by \bigo{1} consequent clones.

\begin{figure}[!ht]
    \colorlet{color-node}{blue!10}

    \centering
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw, minimum width=6mm, minimum height=8mm, anchor=center},
            font=\ttfamily,
            nodes in empty cells,
        },
        edge/.style={->, shorten >= 4pt}
    ]

        \node[] (representation-flat) at (current page.north west) { \mintinline{rust}{Representation::Flat} };
        \matrix[node, fill=green!10, inner sep=0pt] (vec) [below=6mm of representation-flat.south west, anchor=west] { 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\ };

        \draw[|-|]([yshift=-4mm,xshift=1mm]vec-1-1.south west) -- node (c1) [below,font=\scriptsize,outer sep=0mm] {1} ([yshift=-4mm,xshift=-1mm]vec-1-4.south east);
        \draw[|-|]([yshift=-4mm,xshift=1mm]vec-1-5.south west) -- node (c2) [below,font=\scriptsize,outer sep=0mm] {2} ([yshift=-4mm,xshift=-1mm]vec-1-8.south east);
        \draw[|-|]([yshift=-4mm,xshift=1mm]vec-1-9.south west) -- node (c3) [below,font=\scriptsize,outer sep=0mm] {3} ([yshift=-4mm,xshift=-1mm]vec-1-10.south east);

        \node[draw, dashed, inner sep=4mm, fit=(representation-flat) (c2) (vec) (vec)] (representation-flat-box) {};

        \node[] (representation-tree) [below=42mm of representation-flat.south west, anchor=west] { \mintinline{rust}{Representation::Tree} };
        \matrix[node, fill=color-node, inner sep=0pt] (node-1-1) [below=6mm of representation-tree.south] { 00 & 01 & & \\ };
        \draw(node-1-1.north) node[above, draw=none] {root};

        \matrix[node, fill=green!10, inner sep=0pt] (tail) [right=12mm of node-1-1.east] { 8 & 9 & & \\ };
        \draw(tail.north) node[above, draw=none] {tail};

        \matrix[node, fill=green!10, inner sep=0pt] (node-2-2) [below=8mm of node-1-1.south] { 4 & 5 & 6 & 7 \\ };
        \matrix[node, fill=green!10, inner sep=0pt] (node-2-1) [left=2mm of node-2-2.west] { 0 & 1 & 2 & 3 \\ };

        \draw[edge, out=225, in=45] (node-1-1-1-1.south) to (node-2-1.north);
        \draw[edge, out=225, in=45] (node-1-1-1-2.south) to (node-2-2.north);

        \draw[|-|]([yshift=-4mm,xshift=1mm]node-2-1-1-1.south west) -- node (b1) [below,font=\scriptsize,outer sep=0mm] {1} ([yshift=-4mm,xshift=-1mm]node-2-1-1-4.south east);
        \draw[|-|]([yshift=-4mm,xshift=1mm]node-2-2-1-1.south west) -- node (b2) [below,font=\scriptsize,outer sep=0mm] {2} ([yshift=-4mm,xshift=-1mm]node-2-2-1-4.south east);
        \draw[|-|]([yshift=-4mm,xshift=1mm]tail-1-1.south west) -- node (b3) [below,font=\scriptsize,outer sep=0mm] {3} ([yshift=-4mm,xshift=-1mm]tail-1-4.south east);

        \node[draw, dashed, inner sep=4mm, fit=(representation-tree) (b2) (tail) (node-2-1)] (representation-tree-box) {};

        \draw[edge, out=270, in=90] (representation-flat-box.south) to (representation-tree-box.north);
    \end{tikzpicture}

    \caption{Visualization of switching the vector representation}
    \label{fig:switching-representations}
\end{figure}
