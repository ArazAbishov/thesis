\newcommand{\boxptr}{\type{box}}

\chapter{Persistent vector in Rust}

This chapter discusses approaches to define a persistent vector in Rust, their advantages and disadvantages, and their influence on the data structure design:

\begin{itemize}
    \item First, we will take a look at the memory layout of \rrbtree{} and how it supports the implementation of cloning and path copying.
    \item Then, the dynamic representation and unique access optimizations will be introduced in the context of Rust's ownership and borrowing rules.
    \item At last, we will talk about the thread-safety\todo{Use the word consistently in the document} and the Rust requirements for sharing objects between threads.
\end{itemize}

\section{Memory layout}
To define a persistent vector in Rust, we first need to understand how different parts of it are connected in the computer memory, and which Rust constructs are the most suitable for their representation.

The backbone of a confluently persistent vector is \rrbtree{}, with auxiliary properties such as a tail, size, and height. \rrbtree{} consists of infinitely nested nodes, which form a directed acyclic graph\footnote{A graph is a set of nodes connected by edges. In a directed acyclic graph, the edges are connected so that each edge only goes one way without creating a cycle.} in memory.\todo{Add a figure}

Since the data structure can be arbitrarily large, the Rust compiler is not able to reliably measure its size during compilation. Hence, the static memory allocation on the stack is not possible without additional constraints, such as fixed capacity.

In fact, the Rust compiler will abort the compilation if a \emph{recursive data type}\footnote{\url{https://doc.rust-lang.org/book/ch15-01-box.html\#enabling-recursive-types-with-boxes}} definition is encountered. A recursive data type is a type that contains itself, such as a tree node. The solution is to use dynamic memory allocation instead of static. Rust offers a special type of pointers for this purpose, such as \boxptr{}, \rc{}, etc.

As \rrbtree{} employs structural sharing, several tree instances might point to the same sub-trees. In other words, one node can be referenced by several other parent nodes simultaneously. Even though \boxptr{} enables recursive types, it does not allow shared ownership of the underlying value. A smart pointer that supports a notion of shared ownership is known as \rc{} or reference counting pointer.

\subsection{Reference counting pointers}
\todo{A diagram of its memory layout}
In a nutshell, a reference counting pointer allows shared ownership of the object wrapped into it. Every time a potential owner needs a reference to the value, the pointer itself is cloned instead of the underlying object. The reference count is incremented on each clone, and decremented when a pointer goes out of the scope. If the reference count reaches zero, the underlying value is destroyed.

\subsubsection*{Copy-on-write semantics}
Rustâ€™s \rc{} conforms to the ownership and borrowing rules that are enforced during run-time rather than compile-time. It allows shared immutable access to the value as well as regular reference does, and permits unique mutable access only if other references do not exist.

The \emph{make\_mut}\todo{Typesetting of methods} method that is available on \rc{} allows us to safely acquire a mutable pointer to the value regardless of the reference count. If there are other pointers to the same allocation, then \emph{make\_mut} will clone the inner value to a new allocation to ensure unique ownership. This is also referred to as \emph{copy-on-write} behavior. \todo{A diagram demonstrating semantics of rc}

% The standard library also offers an \emph{Arc<T>} type, which is very similar to Rc<T> with the difference that it uses atomic operations to synchronize accesses to its reference counts. This can make Arc<T> a little more expensive during run time, but it enables threads to share a value safely.

% As a persistent vector is intended to be a part of a library, Arc would be a better choice as it creates a foundation for the data structure to be used in the multithreaded environment.

\subsubsection*{Memory reclamation}

\subsubsection*{Thread safety}

\subsubsection*{Path copying}

\subsection{Structures, enumerations and cache locality}
With the knowledge of how \rc{} can help us to manage the memory and its semantics we can move on to the Rust constructs for defining custom data types:

\begin{itemize}
    \item Structures or \emph{structs}: is a custom data type that lets you package together multiple related values\footnote{\url{https://doc.rust-lang.org/book/ch05-00-structs.html}}.
    \item Enumerations or \emph{enums}: allows you to define a type by enumerating its possible \emph{variants}\footnote{\url{https://doc.rust-lang.org/book/ch06-00-enums.html}}.
\end{itemize}

\begin{figure}
    \caption{The memory layout of Rust containers.}
    \label{fig:memory-layout-of-rust-containers}

    \centering
    \begin{tikzpicture}[
        font=\ttfamily,
        nodes={
            draw,
            anchor=center,
            minimum height=8mm,
            text depth=.5ex,
            text height=2ex
        },
    ]
        \node[draw, fill=blue!20, anchor=center, minimum width=14mm, minimum height=8mm, inner sep=4pt] at (current page.north west) (rc) {ptr};
        \draw(rc.north) node[above, draw=none] {\mintinline{rust}{Rc<T>}};

        \matrix[inner sep=4pt] (rcptr) [below = 6mm of rc.south] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=26mm] {T}; \\
        };

        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (rcptr.north west) rectangle (rcptr.south east);
        \end{scope}

        \draw[->, shorten >= 4pt] (rc.south) to (rcptr.north);

        \node[draw, fill=blue!20, anchor=center, minimum width=14mm, minimum height=8mm, inner sep=4pt] [below right=16mm and 52mm of rc.east] (arc) {ptr};
        \draw(arc.north) node[above, draw=none] {\mintinline{rust}{Arc<T>}};

        \matrix[inner sep=4pt] (arcptr) [below = 6mm of arc.south] {
            \node[fill=purple!20, minimum width=14mm] {strong}; &
            \node[fill=purple!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=26mm] {T}; \\
        };

        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (arcptr.north west) rectangle (arcptr.south east);
        \end{scope}

        \draw[->, shorten >= 4pt] (arc.south) to (arcptr.north);

        \matrix[draw=none, inner sep=4pt] (enum-var-1) [below=16mm of rcptr.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=24mm] {A}; &
            \node[fill=white, minimum width=16mm] {}; \\
        };
        \draw(enum-var-1.north) node[above, draw=none] {\mintinline{rust}{enum {A, B, C}}};

        \matrix[draw=none, inner sep=4pt] (enum-var-2) [below=0pt of enum-var-1.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=40mm] {B}; \\
        };
        \matrix[draw=none, inner sep=4pt] (enum-var-3) [below=0pt of enum-var-2.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=14mm] {C}; &
            \node[fill=white, minimum width=26mm] {}; \\
        };
    \end{tikzpicture}
\end{figure}

Struct is a common way of defining a new type in Rust. The arrangement and padding of the struct fields in memory is handled by the compiler to achieve optimal performance. Thus, it is possible that the total size of the struct will exceed the sum of its fields. Inheritance in structs is forbidden by design.

Enumerations are used to define a type that has different variants. Each variant can have a different set of attributes. Pattern matching in the \emph{match} expression makes it easy to run different code for different values of an enum.

If a new enum variant is added, compiler will check that match expressions handle it accordingly. Enums \emph{cannot} be extended with new variants outside of their declaration.

The size of the enum is capped by its largest variant to guarantee that all variants can be used interchangeably. The section below demonstrates why it is critical for the performance.

\subsubsection*{The \rrbtree{} node}

\begin{figure}[H]
    \centering

    \begin{minted}{rust}
        // type SharedPtr<T> = Arc<T> | Rc<T>;

        enum Node<T> {
            RelaxedBranch(SharedPtr<RelaxedBranch<T>>),
            Branch(SharedPtr<Branch<T>>),
            Leaf(SharedPtr<Leaf<T>>),
        }

        struct RelaxedBranch<T> {
            children: [Option<Node<T>>; BRANCH_FACTOR],
            sizes: [Option<usize>; BRANCH_FACTOR],
            len: usize,
        }

        struct Branch<T> {
            children: [Option<Node<T>>; BRANCH_FACTOR],
            len: usize,
        }

        struct Leaf<T> {
            elements: [Option<T>; BRANCH_FACTOR],
            len: usize,
        }
    \end{minted}

    \caption{Definition of the \rrbtree{} node.}
    \label{fig:rrbtree-node}
\end{figure}

As demonstrated in figure \ref{fig:rrbtree-node}, the tree node can be represented by one of the three different types: \mintinline{rust}{RelaxedBranch}, \mintinline{rust}{Branch} or \mintinline{rust}{Leaf}. Leaves hold values, while two other types reference nodes.

\paragraph{Optimising for the cache locality}
An eagle eyed reader will notice that the \mintinline{rust}{Node} enum could have been declared in a more concise way by having the fields defined right within the variant. Even though it seems to be a cleaner approach, it comes with a hidden cost.

\todo{A figure demonstrating this here?}

As mentioned earlier, enums take up as much space as their largest variant. If the node types were declared as in figure \ref{todo}, the enum size will be equal to the size of \mintinline{rust}{RelaxedBranch}. It means that even when the tree is  balanced each node will reserve the space as if they were relaxed.

The more space nodes use, the more likely it is that they will not fit into the CPU cache lines causing more lookups in RAM. This, in turn, directly impacts the performance in the negative way.

To avoid the unnecessarily large memory footprint of the \mintinline{rust}{Node} enum, the decision was made to extract the node fields into structs as demonstrated in the figure \ref{fig:rrbtree-node}. By wrapping the struct instances into a smart pointer such as \rc{}, we explicitly move the allocation of the node to the heap memory.

The size of the \rc{} pointer is independent of the type it encapsulates. Hence, the size of the \mintinline{rust}{Node} enum boils down to the size of the enum tag, the weak and strong reference count fields of \rc{}, and the actual pointer to the heap.

% TODO: Spatial locality, and its subclass sequential locality. Both terms can be used to frame the argument around performance of RrbVec iterators. You **have** to make this point in the discussion chapter on this.
% TODO: a modification of the display and focus optimization was used to improve performance of \rrbvec{}'s iterator:
% The \rrbtree{} iterator does not implement display optimization as described in \ref{todo}. It does, however, consume the tree by chunks. Avoiding the tree traversal on every request to return the next element offsets its cost, and results in overall amortized(effectively?)-constant run-time.