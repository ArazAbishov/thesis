\newcommand{\boxptr}{\type{box}}

\chapter{Persistent vector in Rust}

This chapter discusses approaches to define a persistent vector in Rust, their advantages and disadvantages, and their influence on the data structure design:

\begin{itemize}
    \item First, we will take a look at the memory layout of \rrbtree{} and how it supports the implementation of cloning and path copying.
    \item Then, the dynamic representation and unique access optimizations will be introduced in the context of Rust's ownership and borrowing rules.
    \item At last, we will talk about the thread-safety\todo{Use the word consistently in the document} and the Rust requirements for sharing objects between threads.
\end{itemize}

\section{Memory layout}
To define a persistent vector in Rust, we first need to understand how different parts of it are connected in the computer memory, and which Rust constructs are the most suitable for their representation.

The backbone of a confluently persistent vector is \rrbtree{}, with auxiliary properties such as a tail, size, and height. \rrbtree{} consists of infinitely nested nodes, which form a directed acyclic graph\footnote{A graph is a set of nodes connected by edges. In a directed acyclic graph, the edges are connected so that each edge only goes one way without creating a cycle.} in memory.\todo{Add a figure}

Since the data structure can be arbitrarily large, the Rust compiler is not able to reliably measure its size during compilation. Hence, the static memory allocation on the stack is not possible without additional constraints, such as fixed capacity.

In fact, the Rust compiler will abort the compilation if a \emph{recursive data type}\footnote{\url{https://doc.rust-lang.org/book/ch15-01-box.html\#enabling-recursive-types-with-boxes}} definition is encountered. A recursive data type is a type that contains itself, such as a tree node. The solution is to use dynamic memory allocation instead of static. Rust offers a special type of pointers for this purpose, such as \boxptr{}, \rc{}, etc.

As \rrbtree{} employs structural sharing, several tree instances might point to the same sub-trees. In other words, one node can be referenced by several other parent nodes simultaneously. Even though \boxptr{} enables recursive types, it does not allow shared ownership of the underlying value. A smart pointer that supports a notion of shared ownership is known as \rc{} or reference counting pointer.

\subsection{Reference counting pointers}
\todo{A diagram of its memory layout}
In a nutshell, a reference counting pointer allows shared ownership of the object wrapped into it. Every time a potential owner needs a reference to the value, the pointer itself is cloned instead of the underlying object. The reference count is incremented on each clone, and decremented when a pointer goes out of the scope. If the reference count reaches zero, the underlying value is destroyed.

\subsubsection*{Copy-on-write semantics}
Rustâ€™s \rc{} conforms to the ownership and borrowing rules that are enforced during run-time rather than compile-time. It allows shared immutable access to the value as well as regular reference does, and permits unique mutable access only if other references do not exist.

The \emph{make\_mut}\todo{Typesetting of methods} method that is available on \rc{} allows us to safely acquire a mutable pointer to the value regardless of the reference count. If there are other pointers to the same allocation, then \emph{make\_mut} will clone the inner value to a new allocation to ensure unique ownership. This is also referred to as \emph{copy-on-write} behavior. \todo{A diagram demonstrating semantics of rc}

% The standard library also offers an \emph{Arc<T>} type, which is very similar to Rc<T> with the difference that it uses atomic operations to synchronize accesses to its reference counts. This can make Arc<T> a little more expensive during run time, but it enables threads to share a value safely.

% As a persistent vector is intended to be a part of a library, Arc would be a better choice as it creates a foundation for the data structure to be used in the multithreaded environment.

\subsubsection*{Memory reclamation}

\subsubsection*{Thread safety}

\subsubsection*{Path copying}

\subsection{Structures, enumerations and cache locality}
With the knowledge of how \rc{} helps to manage the memory and its semantics we can move on to the definition of the \rrbtree{} node using the following Rust constructs:
\begin{itemize}
    \item Structures or \emph{structs}: is a custom data type that lets you package together multiple related values\footnote{\url{https://doc.rust-lang.org/book/ch05-00-structs.html}}.
    \item Enumerations or \emph{enums}: allows you to define a type by enumerating its possible \emph{variants}\footnote{\url{https://doc.rust-lang.org/book/ch06-00-enums.html}}.
\end{itemize}

Conceptually, the \rrbtree{} consists of three node types: a balanced branch, a relaxed branch and a leaf. Depending on the tree level, branching nodes reference either other branching nodes or leaves. Thus, the node definition has to be generic over the child node type.

Rust forbids inheritance in structs. It does, however, provide alternative ways of defining data types that are conceptually related: enumerations and \emph{trait objects}\footnote{todo}.

Trait objects are objects that share common behavior by implementing the same interface. The main advantage of trait objects is their extensibility. Enums, on the other hand, cannot be extended with more variants outside of their declaration. Since the tree node is an implementation detail of a persistent vector and is not expected to be extended, enums were favored over trait objects.

Each enum variant can have a different set of fields. Hence, the enum size is capped by its largest variant to guarantee that all variants can be used interchangeably.

\subsubsection*{The \rrbtree{} node}

By using structs and enums in combination with \rc{}, we can finally bring everything together to define the \rrbtree{} node. The figure \ref{fig:rrbtree-node} presents the structure as it is in the library.

\begin{figure}[!htbp]
    \centering

    \begin{minted}{rust}
        #[cfg(feature = "arc")]
        type SharedPtr<T> = Arc<T>;

        #[cfg(not(feature = "arc"))]
        type SharedPtr<T> = Rc<T>;

        // ^ SharedPtr<T> is a type alias that is assigned
        // either Arc<T> or Rc<T> depending on the
        // thread-safety requirements and configuration.

        enum Node<T> {
            RelaxedBranch(SharedPtr<RelaxedBranch<T>>),
            Branch(SharedPtr<Branch<T>>),
            Leaf(SharedPtr<Leaf<T>>),
        }

        struct RelaxedBranch<T> {
            children: [Option<Node<T>>; BRANCH_FACTOR],
            sizes: [Option<usize>; BRANCH_FACTOR],
            len: usize,
        }

        struct Branch<T> {
            children: [Option<Node<T>>; BRANCH_FACTOR],
            len: usize,
        }

        struct Leaf<T> {
            elements: [Option<T>; BRANCH_FACTOR],
            len: usize,
        }
    \end{minted}

    \caption{Definition of the \rrbtree{} node.}
    \label{fig:rrbtree-node}
\end{figure}

Each node type has received its own struct definition. An eagle eyed reader will notice that the \type{Node} enum in figure \ref{fig:rrbtree-node} could have been declared in a more concise way by having the node fields defined directly within the variant. Even though it seems to be a more intuitive approach, it comes at a hidden cost.

% As demonstrated in figure \ref{fig:rrbtree-node}, the tree node can be represented by one of the three different types: \type{RelaxedBranch}, \type{Branch} or \type{Leaf}. Leaves hold values, while two other types reference other nodes.

\paragraph{The enum size and the cache locality}

\begin{figure}[!htbp]
    \centering
    \begin{tikzpicture}[
        font=\ttfamily,
        nodes={
            draw,
            anchor=center,
            minimum height=8mm,
            text depth=.5ex,
            text height=2ex
        },
    ]
        \node[draw, fill=blue!20, anchor=center, minimum width=14mm, minimum height=8mm, inner sep=4pt] at (current page.north west) (rc) {ptr};
        \draw(rc.north) node[above, draw=none] {\mintinline{rust}{Rc<T>}};

        \matrix[inner sep=4pt] (rcptr) [below = 6mm of rc.south] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=26mm] {T}; \\
        };

        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (rcptr.north west) rectangle (rcptr.south east);
        \end{scope}

        \draw[->, shorten >= 4pt] (rc.south) to (rcptr.north);

        \matrix[draw=none, inner sep=4pt] (enum-var-1) [below=16mm of rcptr.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=24mm] {A}; &
            \node[fill=white, minimum width=16mm] {}; \\
        };
        \draw(enum-var-1.north) node[above, draw=none] {\mintinline{rust}{enum {A, B, C}}};

        \matrix[draw=none, inner sep=4pt] (enum-var-2) [below=0pt of enum-var-1.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=40mm] {B}; \\
        };
        \matrix[draw=none, inner sep=4pt] (enum-var-3) [below=0pt of enum-var-2.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=red!20, minimum width=14mm] {C}; &
            \node[fill=white, minimum width=26mm] {}; \\
        };

        \node[draw, fill=blue!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] [right=12mm of rcptr.east] (legptr) {ptr};
        \draw(legptr.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=green!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] [below=6mm of legptr.south west, anchor=west] (legsize) {size};
        \draw(legsize.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=red!20, minimum width=20mm, minimum height=8mm, inner sep=4pt] [below=6mm of legsize.south west, anchor=west] (legt) {T};
        \draw(legt.east) node[right, draw=none] {User defined type};

        \node[draw, fill=yellow!40, minimum width=32mm, minimum height=8mm, inner sep=4pt] [below=6mm of legt.south west, anchor=west] (legalloc) {allocation};
        \draw(legalloc.east) node[right, draw=none] {Heap allocation};
    \end{tikzpicture}

    \caption{The memory layout of Rust containers.}
    \label{fig:memory-layout-of-rust-containers}
\end{figure}

As mentioned earlier, enums take up as much space as their largest variant. If the node fields were declared within the enum variants directly, the enum size would be equal to the size of \mintinline{rust}{RelaxedBranch}, resulting in the balanced tree reserving as much space as if it was relaxed. See an example of how the enum size is calculated in figure \ref{fig:memory-layout-of-rust-containers}.

The more space nodes use, the more expensive the memory allocations are. Also, bigger nodes are more likely to not fit into the CPU cache lines, negatively impacting the performance even more.

To avoid the unnecessarily large memory footprint of the \mintinline{rust}{Node} enum, the decision was made to extract the node fields into structs as demonstrated in the figure \ref{fig:rrbtree-node}. By wrapping the struct instances into a smart pointer such as \rc{}, we explicitly move the allocation of the node to the heap.

The size of the \rc{} pointer is independent of the type it encapsulates. Hence, the size of the \mintinline{rust}{Node} enum boils down to the size of the enum tag, the weak and strong reference count fields of \rc{}, and the actual pointer to the heap.

This, in turn, means that the \mintinline{rust}{Node} enum variants will be equally sized, taking as little space as possible. When compiling the library for a machine with the 64-bit CPU architecture, the enum size is 16 bytes, where 8 bytes are reserved for the enum tag, and 8 bytes for the reference-counted pointer.

\begin{figure}[!htbp]
    \centering
    \begin{tikzpicture}[
        font=\ttfamily,
        nodes={
            draw,
            anchor=center,
            minimum height=8mm,
            text depth=.5ex,
            text height=2ex
        },
    ]
        \node[draw, fill=blue!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] at (current page.north east) (legptr) {ptr};
        \draw(legptr.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=green!20, minimum width=14mm, minimum height=8mm, inner sep=4pt] [below=6mm of legptr.south west, anchor=west] (legsize) {size};
        \draw(legsize.east) node[right, draw=none] {4/8 bytes};

        \node[draw, fill=red!20, minimum width=20mm, minimum height=8mm, inner sep=4pt] [below=6mm of legsize.south west, anchor=west] (legt) {T};
        \draw(legt.east) node[right, draw=none] {User defined type};

        \node[draw, fill=yellow!40, minimum width=32mm, minimum height=8mm, inner sep=4pt] [below=6mm of legt.south west, anchor=west] (legalloc) {allocation};
        \draw(legalloc.east) node[right, draw=none] {Heap allocation};

        \matrix[draw=none, inner sep=4pt] [below left=4mm and 8mm of legalloc.west] (enum-var-relaxed-branch) {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=blue!20, minimum width=48mm] {\mintinline{rust}{Rc<RelaxedBranch<T>>}}; \\
        };
        \draw(enum-var-relaxed-branch.north) node[above, draw=none] {\mintinline{rust}{enum Node}};

        \matrix[draw=none, inner sep=4pt] (enum-var-branch) [below=0pt of enum-var-relaxed-branch.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=blue!20, minimum width=48mm] {\mintinline{rust}{Rc<Branch<T>>}}; \\
        };
        \matrix[draw=none, inner sep=4pt] (enum-var-leaf) [below=0pt of enum-var-branch.south] {
            \node[fill=green!20, minimum width=14mm] {tag}; &
            \node[fill=blue!20, minimum width=48mm] {\mintinline{rust}{Rc<Leaf<T>>}}; \\
        };

        \matrix[draw=none, inner sep=4pt] (relaxed-branch) [below right=12mm and 2mm of enum-var-leaf.south] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=22mm] {children}; &
            \node[fill=red!20, minimum width=14mm] {sizes}; &
            \node[fill=red!20, minimum width=14mm] {len}; \\
        };
        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (relaxed-branch.north west) rectangle (relaxed-branch.south east);
        \end{scope}

        \matrix[draw=none, inner sep=4pt] (branch) [below=8mm of relaxed-branch.south west, anchor=west] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=22mm] {children}; &            
            \node[fill=red!20, minimum width=14mm] {len}; \\
        };
        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (branch.north west) rectangle (branch.south east);
        \end{scope}

        \matrix[draw=none, inner sep=4pt] (leaf) [below=8mm of branch.south west, anchor=west] {
            \node[fill=green!20, minimum width=14mm] {strong}; &
            \node[fill=green!20, minimum width=14mm] {weak}; &
            \node[fill=red!20, minimum width=22mm] {elements}; &            
            \node[fill=red!20, minimum width=14mm] {len}; \\
        };
        \begin{scope}[on background layer]
            \draw[fill=yellow!40] (leaf.north west) rectangle (leaf.south east);
        \end{scope}

        \draw[->, shorten >= 4pt, out=0, in=90] (enum-var-relaxed-branch.east) to (relaxed-branch.north);
        \draw[->, shorten >= 4pt, out=0, in=180, looseness=2] (enum-var-branch.east) to (branch.west);
        \draw[->, shorten >= 4pt, out=0, in=0, looseness=2] (enum-var-leaf.east) to (leaf.east);
    \end{tikzpicture}

    \caption{The memory layout of the \rrbtree{} node.}
    \label{fig:memory-layout-of-rrbtree-node}
\end{figure}

% TODO: Spatial locality, and its subclass sequential locality. Both terms can be used to frame the argument around performance of RrbVec iterators. You **have** to make this point in the discussion chapter on this.
% TODO: a modification of the display and focus optimization was used to improve performance of \rrbvec{}'s iterator:
% The \rrbtree{} iterator does not implement display optimization as described in \ref{todo}. It does, however, consume the tree by chunks. Avoiding the tree traversal on every request to return the next element offsets its cost, and results in overall amortized(effectively?)-constant run-time.