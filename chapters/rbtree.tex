\chapter{Radix Balanced Tree}

Radix Balanced Tree or \rbtree, is a wide tree data structure with a fixed number of children per node, which allows access to values using integer keys. It was first introduced by Rich Hickey as a basis for the persistent vector implementation in Clojure's standard library \cite{the-clojure-programming-language}. 

Most persistent data structures are tailored to specific use cases, with some operations being faster than others. For example, a persistent linked list can prepend elements and read the head in \bigo{1} time. However, random access is proportional to \bigo{n}, which is unacceptable in practical scenarios. 

In comparison, Clojure's vector implementation is delivering \emph{practically} \bigo{1} time on fundamental operations such as access, update, push, and pop, rivaling ephemeral vector in performance.

This chapter introduces the inner workings of \rbtree{} and covers algorithms used in the core operations. For a more formal description of the persistent vector, refer to \cite{improving-performance-through-transience}. 

\section{Memory layout}
\label{sec:rb-tree-memory-layout}

\rbtree{} consists of nodes which contain references to other subtrees or to values. We will be calling the former type of node as \emph{branch} node, while the latter one as \emph{leaf}. The number of subtrees and values in the node is configurable and will be denoted as \m, also known as \emph{branching factor}. 

When \m\ is set to a large value, the tree becomes wide and shallow. In practice, the branching factor is set to 32 to achieve \emph{practically} \bigo{1} performance across different operations, but this number can be any power of 2.

From now on the height of the tree will be referred to as \h{}, where $h_{max}$ is the upper boundary:

\begin{equation}
    h_{max} = log_m(n).
\end{equation}

If \m{} is 32 and the number of elements will never be larger than the maximum index representable with 32 bit signed integers, the maximum height of the tree will not exceed 7 levels. 

References to values are stored at the leaf nodes of the tree. If the count of values stored in the structure is less than branching factor, then the root node itself will be a leaf. Otherwise, capacity of the tree is increased by adding intermediate branch nodes. 

\section{Radix search}

Before trying to understand how operations such as push, pop, and update work, let's take a look at how to access values in \rbtree{}. The lookup mechanism is called \emph{radix search}, a fundamental algorithm which forms the basis for other operations.

Conceptually, the idea behind the search in an ordered tree-like structure boils down to picking correct nodes based on the given key. If there is a value corresponding to the key, we stop searching and return the value. Otherwise, an empty value or error is returned.

The lookup mechanism depends on organization of nodes in the tree. Let's consider an example where each node has at most two children, called \emph{binary tree}. A binary tree where every node fits a specific ordering property\footnote{For every node $n$, all left descendents must be less than or equal than $n$, and all right descendents must be strictly bigger than $n$.} is called \emph{binary search tree}. While searching, the key at each node is compared to the search key. All that is important is whether the key in the node is less than, equal to, or greater than the search key. The search is continued until an exact match or reaching a leaf node.

Another tree-like data structure known as trie, is interesting because its nodes do not store complete keys. Instead, each node stores only part of it. Since tries are often used for the prefix search of words, their nodes store characters. Each path down the tree may represent a word. A node in a trie could have anywhere from 0 through the size of the alphabet children. For example, the english alphabet has 26 letters, meaning that each node might have up to 26 children.

The lookup procedure for tries involves breaking down the search key into multiple sub-keys, which are used to pick corresponding sub-tries. For example, the key "car" will be broken down into several smaller keys such as "c", "a", "r". If there is a value present at the last node of the path, it is returned. Otherwise, an empty value or error is returned. 

\subsection*{Bit partitioning}

\rbtree{} is a variation of a trie, which is also known as \emph{persistent bit-partitioned vector trie}. So what does make it so special? 

A search key in \rbtree{} is an integer, which can be viewed as a composite key, where each sub-key is represented by a sequence of bits. The idea is to divide the key into blocks of bits, where each block forms an index specific to the tree node. The count of bits in each of those chunks can be derived from the branching factor and will be called as \emph{bits per level}.

The \emph{bits per level} or \x{} is the count of bits used to address \m{} nodes in the binary numeral system. The relationship between \m{} and \x{} can be represented as: 

\begin{equation}
    2^x = m
\end{equation}

This leads us to a formula which derives the count of \emph{bits per level} from \m{}: 

\begin{equation}
    \label{eq:bits-per-level}
    x = log_2(m)
\end{equation}

For example, with \m{} equal to 16, the maximum index value is 15. 15 converted to the binary form is $1111_2$, which evidently requires 4 bits of space. If we substitute \m{} into \Cref{eq:bits-per-level}, we will get the same value. 

\subsection*{Extracting sub-keys}

Now when the size of the sub-key is known, next step is to identify its location. The count of sub-keys within the search key depends on the heght of the tree. Each new level in \rbtree{} will use \x{} additional bits of space. For instance, a search key addressing an element of the tree of ${h = 3}$ and ${x = 2}$ will consist of 3 sub-keys taking up 6 bits of space in total.

Sub-keys are arranged in the order from the most to the least significant bits, where the most significant sequence is a key used to access child node of the root. Each following key is used to index into child node on the corresponding tree level.

Knowing the depth at which a node is located and the count of bits per level, the value of the key can be calculated using bitwise operations such as logical shift and masking. Let's take a look at mechanism used to extract the right sub-key. 

In the following example there is a byte which represents a key equal to 54. Let's assume that it belongs to the tree where \m{} is 4, \x{} is 2 and that height of the tree 3. 

\begin{equation}
    54_{10} = 00110110_2    
\end{equation}

Since there are three levels, we have only three sub-keys: $11_2$, $01_2$ and $10_2$. Let's say that we are interested in extracting sub-key for the child node on the second level --- $01_2$. 

First, let's get rid of the bits following the sub-key of our interest. Logical right shift operation --- $\ggg$, will push $(l - 1) * x$ 0s into key, where $l$ is the \emph{level} at which current node is located. 

\begin{equation}
    00110110 \ggg ((l - 1) * x)
\end{equation}

Since the node in the example is located at $l = 2$ and $x = 2$, the search key will be shifted by 2. The result of operation is $00001101_2$. As you can see, the "tail" of the key is truncated.

The next step is to get rid of bits preceding the sub-key by masking them to 0. An operator used for this is known as bitwise "and" and it will be applied to the result of shifting operation. 

A bitwise "and" takes two equal-length binary representations and performs the logical "and" operation on each pair of the corresponding bits. 

Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1; otherwise, the result is 0. Here is an example:

\begin{equation}
    00001101 \ \& \ 00000011 = 00000001
\end{equation}
                                    
The first and the second operands are the key and mask respectively. 

Only the last two bits of the mask are set to 1, which means that all bits of the key except last two will be masked to 0. The result of the "and"-ing operation will be the value of the sub-key.

Now the question is how to define a mask and what are the requirements to it. First of all, it has to be of the same type as the key, meaning that it must have the same count of bits in the binary representation. Secondly, the last \x bits must be set to 1.

The mask is equal to the maximum value of the sub-key, which can be calculated from the branching factor:

\begin{equation}
    mask = m - 1
\end{equation}

If \m{} is equal to 4 the maximum sub-key value will be 3, which equals to 00000011 in the binary representation.

\subsection*{Summary}

\begin{figure}        
    \caption{Accessing element at index 104 in a tree of height 4. Empty nodes represent collapsed subtrees.}
    \label{fig:rb-tree-example-1}

    \centering
    \begin{tikzpicture} [    
        node/.style = { 
            matrix of nodes, 
            nodes = { draw, minimum width = 6mm, minimum height = 8mm, anchor = center},
            font = \small,
            nodes in empty cells        
        },    
        value/.style = { 
            matrix of nodes, 
            nodes = { draw = none, minimum width = 4mm, minimum height = 4mm, anchor = center, rotate = 90 },
            font = \small,            
            nodes in empty cells        
        },    
        edge/.style = { ->, shorten >= 4pt }
    ]   
        \node[] (index) at (current page.north west) { $104_{10}$ = $01 10 10 00_{2}$ };        
        
        \matrix[node] (node-1-1) [below right = 8mm and 1cm of index] { 00 & 01 & 10 & 11 \\ };
                
        \scoped[on background layer] {
            \node[fit=(node-1-1-1-1), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-1-1-1-2), fill=color-path, inner sep = 0pt]   {};
            \node[fit=(node-1-1-1-3), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-1-1-1-4), fill=color-node, inner sep = 0pt]   {};
        }
        
        \matrix[node, inner sep = 0pt] (node-2-2) [below left = 8mm and 1mm of node-1-1.south] { 00 & 01 & 10 & 11 \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-2-3) [below right = 8mm and 1mm of node-1-1.south] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-2-1) [left = 2mm of node-2-2.west] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-2-4) [right = 2mm of node-2-3.east] { & & & \\ };

        \scoped[on background layer] {
            \node[fit=(node-2-2-1-1), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-2-2-1-2), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-2-2-1-3), fill=color-path, inner sep = 0pt]   {};
            \node[fit=(node-2-2-1-4), fill=color-node, inner sep = 0pt]   {};
        }

        \draw[edge, out=225, in=45] (node-1-1-1-1.south) to (node-2-1.north);
        \draw[edge, out=225, in=45] (node-1-1-1-2.south) to (node-2-2.north);
        \draw[edge, out=315, in=135] (node-1-1-1-3.south) to (node-2-3.north);
        \draw[edge, out=315, in=135] (node-1-1-1-4.south) to (node-2-4.north);

        \matrix[node, fill = color-node, inner sep = 0pt] (node-3-2) [below left = 8mm and 1mm of node-2-2.south] { & & & \\ };
        \matrix[node, inner sep = 0pt] (node-3-3) [below right = 8mm and 1mm of node-2-2.south] { 00 & 01 & 10 & 11 \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-3-1) [left = 2mm of node-3-2.west] { & & & \\ };        
        \matrix[node, fill = color-node, inner sep = 0pt] (node-3-4) [right = 2mm of node-3-3.east] { & & & \\ };

        \scoped[on background layer] {
            \node[fit=(node-3-3-1-1), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-3-3-1-2), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-3-3-1-3), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-3-3-1-4), fill=color-path, inner sep = 0pt]   {};
        }

        \draw[edge, out=225, in=45] (node-2-2-1-1.south) to (node-3-1.north);
        \draw[edge, out=225, in=45] (node-2-2-1-2.south) to (node-3-2.north);
        \draw[edge, out=315, in=135] (node-2-2-1-3.south) to (node-3-3.north);
        \draw[edge, out=315, in=135] (node-2-2-1-4.south) to (node-3-4.north);

        \matrix[node, fill = color-node, inner sep = 0pt] (node-4-2) [below left = 8mm and 1mm of node-3-3.south] { & & & \\ };        
        \matrix[node, fill = color-node, inner sep = 0pt] (node-4-3) [below right = 8mm and 1mm of node-3-3.south] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-4-1) [left = 2mm of node-4-2.west] { & & & \\ };        
        \matrix[node, inner sep = 0pt] (node-4-4) [right = 2mm of node-4-3.east] { 00 & 01 & 10 & 11 \\ };

        \scoped[on background layer] {
            \node[fit=(node-4-4-1-1), fill=color-path, inner sep = 0pt]   {};
            \node[fit=(node-4-4-1-2), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-4-4-1-3), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-4-4-1-4), fill=color-node, inner sep = 0pt]   {};
        }
        
        \draw[edge, out=225, in=45] (node-3-3-1-1.south) to (node-4-1.north);
        \draw[edge, out=225, in=45] (node-3-3-1-2.south) to (node-4-2.north);
        \draw[edge, out=315, in=135] (node-3-3-1-3.south) to (node-4-3.north);
        \draw[edge, out=315, in=135] (node-3-3-1-4.south) to (node-4-4.north);

        \matrix[value] (node-5-1) [below = 0mm of node-4-1.south] { 139 & 140 & 141 & 142 \\ };
        \matrix[value] (node-5-2) [below = 0mm of node-4-2.south] { 143 & 144 & 145 & 146 \\ };
        \matrix[value] (node-5-3) [below = 0mm of node-4-3.south] { 147 & 148 & 149 & 150 \\ };
        \matrix[value] (node-5-4) [below = 0mm of node-4-4.south] { 151 & 152 & 153 & 154 \\ };
    \end{tikzpicture}
\end{figure}

Let's put everything together and review the radix search step by step based on the concrete example. In \Cref{fig:rb-tree-example-1}, we can see a part of the \rbtree{} which represents elements of persistent vector in the range [92, 107].

The branching factor of the tree is equal to 4, which means that 2 bits will be used for the sub-key representation. The mask is equal to 3 or 00000011 in the binary representation.

The index type is \emph{unsigned byte}, which has a capacity of 256 \footnote{The capacity of any integer type can be calculated by taking the base of the system --- 2, to the power of bits available for its representation. For byte, it will be $2^8 = 256$.}. In practice, the index type is usually a 32 or a 64 bit integer, which has significantly bigger capacity.

The height of the tree in the given state is 4. The node at the top is root, while nodes at the bottom are leaves. The goal is to lookup the contents of an element corresponding to the key 104. 104 in binary representation is equal to 01101000. \Cref{lst:rb-tree-radix-search} outlines the radix search algorithm implementation. 

The search process starts by initializing the node and level variables to root and $height - 1$ correspondingly. The for loop runs until the leaf node level is reached, where each step towards it involves selecting a child node by using bit shifting and masking. After exiting the for loop, function returns the value from the leaf node. 

\begin{listing}[ht!]        
    \caption{Pseudocode for the RB-Tree's radix search implementation}
    \label{lst:rb-tree-radix-search}

    \begin{algorithmic}
        \Function{RadixSearch}{root, key}
            \State $node \leftarrow root$

            \For{$level \leftarrow root_{height} - 1, 1$}
                \State $index \leftarrow (key \ggg (level * x))\ \&\ mask$
                \State $node  \leftarrow node[index]$
            \EndFor

            \State $index \leftarrow key\ \&\ mask$
            \State \Return ${node[index]}$
        \EndFunction
    \end{algorithmic}
\end{listing}

\section{Update}
The purpose of the update operation is to replace the value in the instance of \rbtree{} for the given search  key. 

\emph{Emphemeral} update is \emph{destructive}, meaning that the original \emph{version} of the data structure will be no longer available after the operation is executed. For \emph{persistent data structures}, update results in the new \emph{version} including the updated value without the original becoming unavailable. 

\emph{Version} is something what differentiates one instance of the \rbtree{} from another. Instead using an explicit versioning such as assigning unique numbers to instances of \rbtree{}, we will rely on the memory address as unique identifier. 

The update function accepts two arguments: a search key and a new value. If operation is successfully executed, It returns a new instance of \rbtree{}. If the search key is not present in the original version, new value is either ignored or error is returned. 

There are a few challenges associated with the implementation. If radix search was only reading values without any modifications, update is supposed to both change the value for the given key and ensure that the original structure stays unmodified. 

\subsection*{Path copying}
Radix search will be used to find the value corresponding to the given key. In order to make sure that original data structure is not modified, each branch and leaf node on the way from the root to the value will be copied. This process is also know as \emph{path copying} \cite{planar-point-location}. It is important to emphasize that nodes which are not a part of the path are reused, instead of being recreated. 

In order to get a sense of how well path copying performs, let’s review the whole process in reverse. The leaf node update creates a copy of underlying array of size \m{}. Then, the \m{} sized parent branch node is copied as well, where the fresh copy of the leaf is used instead of the original. The other children of the parent are reused. The same process applies to the grand parent and so on all the way up to the root.  

To summarize, the update operation performs the \h{} count copies of \m{} sized nodes, where \h{} is the maximum height of the tree. As described in \Cref{sec:rb-tree-memory-layout}, \h{} is bound by \bigo{log_m(n)}, which results in the {\bigo{m * log_m(n)}} complexity of the update operation. 

When branching factor \m{} is set to a large value such as 32, performance becomes \bigo{1} in practice. For example, if the tree was completely full, where the count of all elements $n$ is bound by the maximum value of 32 bit integer —  2147483647, \h{} will be at most 7. Since both \h{} and \m{} are effectively constant factors, the resulting performance is proportional to \bigo{1}. 

\begin{listing}[ht!]        
    \caption{Pseudocode for the RB-Tree's update implementation}
    \label{lst:rb-tree-update}
    
    \begin{algorithmic}
        \Function{Update}{root, key, value}
            \State $newRoot \leftarrow clone(root)$
            \State $node \leftarrow newRoot$
    
            \For{$level \leftarrow root_{height} - 1, 1$}
                \State $index \leftarrow (key \ggg (level * x))\ \&\ mask$
                \State $newChildNode \leftarrow clone(node[index])$
                \State $node[index] \leftarrow newChildNode$
                \State $node \leftarrow newChildNode$
            \EndFor
    
            \State $index \leftarrow key\ \&\ mask$
            \State $node[index] \leftarrow value$            
            \State \Return $newRoot$
        \EndFunction
    \end{algorithmic}
\end{listing}

Based on \Cref{lst:rb-tree-update}, the update operation is very similar to radix search from the implementation standpoint. The main difference is that every visited node must be copied, including root. The return value is the root node to the new version of the tree. 

\section{Push} 
The push operation is used to add new elements to the end of \rbtree{}. It employs the \emph{path copying} mechanism to minimize the cost and maximize performance of the operation. It accepts a root node and a new value as arguments, and returns a new version of the tree. 

A key for the new element is equal to the count of elements in \rbtree{}, also known as \emph{size}. For example, if the size is equal to 9, the key for the new value will also be equal to 9. After operation is executed, the size will be incremented by 1. 

The main difference between the update and the push operation is that the latter one has to take care of allocating more space for new elements. If the rightmost leaf node has available slots, then behavior of push is very similar to update. Otherwise, there are two additional scenarios in which either the rightmost leaf is completely full or there is no more space left in the root node. 

Solution for the first case flows from the radix search algorithm. Given a unique key, it calculates a path for the new value, which will never lead to a full leaf node. What might happen is that a path will include nodes which are not created yet. This can be solved by generating them on demand. 

The second case, also known as \emph{root overflow}, occurs when the \emph{size} of the tree exceeds its \emph{capacity}. \emph{Capacity} is the maximum number of elements a tree can accommodate, which can be calculated based on the height \h{} and the branching factor \m{} of \rbtree{}:

\begin{equation}
	capacity = m^h.
\end{equation}

The algorithm for this calculation is based on the left bit shift operation, described in \Cref{lst:rb-tree-capacity}. 

Root overflow can be solved by adding a new level to the tree. This is done by creating a new root node and setting the old root as the first child of the new root. The rest is handled by generating new nodes in the path to the new value. For more details, see \Cref{lst:rb-tree-push}. 

\begin{listing}[ht!]        
    \caption{Pseudocode for the RB-Tree's capacity implementation}
    \label{lst:rb-tree-capacity}
    
    \begin{algorithmic}
        \Function{Capacity}{h}
		\State \Return $m \ll ((h - 1) * x)$
        \EndFunction
    \end{algorithmic}
\end{listing}

\begin{listing}[ht!]        
    \caption{Pseudocode for the RB-Tree's push implementation}
    \label{lst:rb-tree-push}
    
    \begin{algorithmic}
        \Function{Push}{root, value}
            \State $newRoot \leftarrow NIL$

            \If{$capacity(root_{height}) <= root_{size}$}                
                \State $newRoot \leftarrow CreateNode()$
                \State $newRoot[0] \leftarrow Clone(root)$
                \State $newRoot_{height} \leftarrow root_{height} + 1$
            \Else 
                \State $newRoot \leftarrow Clone(root)$
            \EndIf
                        
            \State $node \leftarrow newRoot$
            \State $key \leftarrow newRoot_{size}$
    
            \For{$level \leftarrow newRoot_{height} - 1, 1$}
                \State $index \leftarrow (key \ggg (level * x))\ \&\ mask$
                
                \State $childNode \leftarrow node[index]$
                \State $newChildNode \leftarrow NIL$

                \If{$childNode = NIL$}
                    \State $newChildNode \leftarrow CreateNode()$
                \Else
                    \State $newChildNode \leftarrow clone(childNode)$
                \EndIf
                
                \State $node[index] \leftarrow newChildNode$
                \State $node \leftarrow newChildNode$
            \EndFor        
    
            \State $index \leftarrow key\ \&\ mask$
            \State $node[index] \leftarrow value$ 

            \State $newRoot_{size} \leftarrow newRoot_{size} + 1$
            \State \Return $newRoot$
        \EndFunction
    \end{algorithmic}
\end{listing}

\section{Pop}

Removing items from \rbtree{} is made possible by the pop operation. Together with push, it conforms to the LIFO \footnote{Last In First Out} principle which is typical for the stack abstract data type. It accepts root as input and returns both a popped value and a new version of a structure. 

Pop is responsible for reducing capacity of \rbtree{} when necessary, including removal of branch and leaf nodes when they become empty. As with other operations, modifications are kept to the minimum by taking advantage of path copying algorithm. 

\begin{listing}[ht!]        
    \caption{Pseudocode for the RB-Tree's pop implementation}
    \label{lst:rb-tree-pop}
    
    \begin{algorithmic}
        \Function{PopNode}{node, key}
            \State $newNode \leftarrow Clone(node)$
            \State $value \leftarrow NIL$

            \If{$node_{height} = 0$}                
                \State $index \leftarrow key\ \&\ mask$
                \State $value \leftarrow newNode[index]$
                \State $newNode[index] \leftarrow NIL$
            \Else                 
                \State $index \leftarrow (key \ggg (newNode_{height} * x))\ \&\ mask$
                \State $value, childNode \leftarrow PopNode(newNode[index], key)$                
                \State $newNode[index] \leftarrow childNode$
            \EndIf
            
            \If{$newNode[0] = NIL$}
                \State \Return $value, NIL$
            \Else
                \State \Return $value, newNode$
            \EndIf
        \EndFunction
        \State        
        \Function{Pop}{root}
            \State $value, newRoot \leftarrow PopNode(root, root_{size} - 1)$
            
            \If{$newRoot[1] = NIL)$}                                
                \State $newRoot \leftarrow newRoot[0]$            
            \EndIf

            \State \Return $value, newRoot$
        \EndFunction
    \end{algorithmic}
\end{listing}

Since \rbtree{} is a complete tree, it is true that all entries to the right of \emph{NIL} must be absent as well. As shown in \Cref{lst:rb-tree-pop}, \emph{NIL} checking the 0th entry is sufficient to understand if a node must be removed. If it is true, the empty child will be replaced with a \emph{NIL} reference in the parent node. 

Lowering the height of the tree is crucial from both performance and memory consumption standpoints. A root is considered to be redundant if it contains only a single child node, which is true if the second entry is \emph{NIL}.  The original root is demoted by replacing it with the first child node, which becomes the new root. 

\section{Tail optimization for persistent vector}

In practice, changes are often confined to the end or \emph{tail} of the data structure. Stack is specifically designed for such use cases, by offering constant performance for the push and pop operations. 

Even though \rbtree\ has similar performance characteristics in practice, its push and pop implementations include pesky constant factors in the form of \emph{radix search} and \emph{path copying} algorithms. 

The \emph{tail} optimization is intended to offset this cost by reducing count of \rbtree\ accesses. Instead of adding or removing elements one by one, changes are batched in the array of size \m\. This array could be thought as of  a leaf node, which is attached to the tree only when it is full. 

The following sections review changes in the core operations including the \emph{tail} optimization. 

\subsection*{Optimizing the push operation}
As shown in \Cref{lst:pvec-push}, the value is set into a cloned tail at the position $tail_{size}$. Since \rbtree\ is a complete tree, the rightmost leaf node is the only node which can be empty or semi-full. As the rightmost leaf node is the tail, its size can be used as an index for the new value.

If after update the tail is full, it will be pushed into a tree and replaced with an empty tail. 

\begin{listing}[ht!]        
    \caption{Tail optimization for persistent vector’s push implementation}
    \label{lst:pvec-push}
    
    \begin{algorithmic}
        \Function{Pvec-Push}{vec, value}        
        \State newTail \la Clone(vec\ts{tail})
        \State newTail[tail\ts{size}] \la value
        \State newTail\ts{size} \la tail\ts{size} + 1
        \State newRoot \la vec\ts{root}
            
        \If{newTail\ts{size} = m}
            \State newRoot \la RbTree-Push(vec\ts{root}, newTail)
            \State newTail \la CreateNode()
        \EndIf
        
        \State \Return CreateVec(newRoot, newTail)
        \EndFunction
    \end{algorithmic}
\end{listing}

\subsection*{Optimizing the pop operation}

Now when the tail holds last elements, pop has to retrieve values from it instead of \rbtree. Removing values from the tail is trivial, but with an assumption that it is not empty. There are certain conditions which have to be met for this to be true. First, a vector has to contain at least one value. Second, every time the last element is removed from the tail, it has to be replaced with a new one by popping a leaf from \rbtree. See \Cref{lst:pvec-pop} for more details. 

\begin{listing}[ht!]
    \caption{Tail optimization for persistent vector’s pop implementation}
    \label{lst:pvec-pop}
    
    \begin{algorithmic}
        \Function{Pvec-Pop}{vec}
        
        \State newTail \la Clone(vec\ts{tail})
        \State newRoot \la NIL

        \State value \la newTail[newTail\ts{size} - 1]
        \State newTail\ts{size} \la newTail\ts{size} - 1     
            
        \If{newTail\ts{size} = 0}
            \State newRoot, newTail \la RbTree-Pop(vec\ts{root})            
        \Else 
            \State newRoot \la vec\ts{root}
        \EndIf
        
        \State \Return CreateVec(newRoot, newTail)
        \EndFunction
    \end{algorithmic}
\end{listing}

\subsection*{Adapting the update and radix search operations}
Changes for both update and radix search are very similar, with difference that update has to ensure that original vector stays unmodified. 

Since values are residing both in \rbtree\ and tail, one has to check where the given search key is located. A value is located within the tree if the key is less than the tree size. In this case the search process is delegated to \rbtree. Otherwise, the index for value in the tail is calculated by subtracting the tree size from the key. 

\begin{listing}[ht!]
    \caption{Adapting the update operation to support tail}
    \label{lst:pvec-update}
    
    \begin{algorithmic}
        \Function{Pvec-Update}{vec, key, value}

        \State root \la vec\ts{root}
        \State tail \la vec\ts{tail}

        \If{key < root\ts{size}}
            \State newRoot \la RbTree-Update(root, key, value)
            \State \Return CreateVec(newRoot, tail)
        \Else
            \State newTail \la Clone(tail)
            \State newTail[key - root\ts{size}] \la value
            \State \Return CreateVec(root, newTail)
        \EndIf        
        \EndFunction
    \end{algorithmic}
\end{listing}

\begin{listing}[ht!]
    \caption{Adapting the radix search operation to support tail}
    \label{lst:pvec-radix-search}
    
    \begin{algorithmic}
        \Function{Pvec-Radix-Search}{vec, key}
        
        \State root \la vec\ts{root}
        \State tail \la vec\ts{tail}

        \If{key < root\ts{size}}
            \State \Return RbTree-Radix-Search(root, key)            
        \Else            
            \State \Return tail[key - root\ts{size}]            
        \EndIf
        \EndFunction
    \end{algorithmic}
\end{listing}