\newcommand{\balanced}{}
\newcommand{\standard}{\emph{(s)}}
\newcommand{\relaxed}{\emph{(r)}}

\chapter{Benchmarks and results}
In this chapter, we will take a look at the results of the sequential and parallel benchmarks, and discuss whether proposed\todo{ref} performance optimizations are effective.

The sequential benchmark results are subdivided per the core operation and listed under the \ref{sec:perf-seq} section. Performance of the threadsafe implementation is evaluated separately.

The parallel benchmark results in section \ref{sec:perf-par} are not discussed by operation, as they focus on the overall performance comparison of vectors rather than particular operation in isolation.

The results are discussed to address the following points:
\begin{itemize}
    \item Effect of \rrbtree{} relaxation on concatenation, splitting, and other core operations of \rrbvec{} and \pvec{}.
    \item The impact of the unique access optimization on the performance of all vector implementations.
    \item Effectiveness of the dynamic representation.
\end{itemize}

\paragraph{Reading notes}
Implementations that are prefixed with \relaxed{} in the figure legend were configured to use the relaxed \emph{rb} tree in the benchmark. \standard{} stands for standard and will be applied only to \pvec{} when it is flat. If not specified, the vector is backed by the balanced \rbtree{}.

\section{Sequential benchmark results}
% > =================================================================================
Each benchmark described in this section focuses on a particular core operation of a vector. To avoid ambiguous results, each test exercises only one operation at a time. Operations that modify vector, such as push, will have a complementary version of the benchmark, which also uses the clone operation. This is necessary for comparison of the path copying and naive algorithms used in the tree-based and standard vectors correspondingly.

\todo{Put this table where you first define core operations}
The following operations were evaluated for vector implementations in \ref{tab:vec-implementations}:
\begin{table}[!htbp]
    \centering

    \begin{tabular} { |l| p{10cm} | }
        \hline
        Indexing & Accessing vector values. \\ \hline
        Updating & Updating existing values. \\ \hline
        Pushing & Adding new values to the end of a vector. \\ \hline
        Popping & Removing values at the end of a vector. \\ \hline
        Appending & Concatenating values of one vector to another. \\ \hline
        Splitting & Slicing one vector into two at a given position. \\ \hline
    \end{tabular}

    \label{tab:vec-core-operations}
    \caption{A table of core operations.}
\end{table}

\paragraph{Benchmark structure}
Some benchmarks depend on preconditions. For example, to test indexing, we first need to create a vector with values. Since building a vector instance is not a part of that test, it happens in the setup routine. Hence, benchmarks with preconditions are executed in two steps: setup and the actual test.

\paragraph{Benchmarking dimensions}
Every benchmark for a core operation is parameterized over the vector size. By providing different arguments, we can observe how the performance of vectors is affected in response. This is especially insightful for the tree-based implementations, where the size of the vector influences the height of the tree, which has a negative impact on performance. The output of a benchmark for a given size is the mean runtime in \millis{}.
% < =================================================================================

\label{sec:perf-seq}
This section contains performance numbers for the non-threadsafe implementations of \stdvec{}, \rbvec{}, \rrbvec{}, \pvec{}, and \imrsvec{}. Threadsafe variants are evaluated and discussed separately in section \ref{sec:perf-rc-vs-arc}.

\subsection{Indexing}
% > =================================================================================
In this section, we will define benchmarks for accessing values in three different configurations, which model the most common ways of working with vector:

\begin{itemize}
    \item Sequentially accessing values by index and iterator.
    \item Accessing values at randomly generated indices.
\end{itemize}

Use cases listed above address two objectives: first, how much overhead relaxed nodes of \rrbtree{} introduce in comparison to \rbtree{}, and second, the efficiency of the dynamic representation in \pvec{}.

The indexing benchmarks share the same setup routine for generating a vector. Balanced tree-based vectors are created by pushing 64-bit integers, while the relaxed types are generated by concatenating vectors together.

The vector size is passed as an argument and falls into the range of \range{[20, \mega{1}]}.
% < =================================================================================

Figures for the index operation are separated by sequential and random access, where the sequential benchmark results are subdivided into the index and iterator figures.

\subsubsection*{Index sequentially}
% > =================================================================================
The benchmark with access by index loops over the array of \range{[0, N)} indices, and reads values from a vector at corresponding positions. Values are read by using immutable references without taking ownership of them.

The iterators test reads the contents of the tree-based vectors by chunks, rather than by individual values. Additionally, iterator takes ownership of values instead of borrowing them. Due to these differences, the results of this benchmark will not be compared to the access by index.
% < =================================================================================

\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/index_sequentially/im-rs-vector-balanced.csv}\idxseqimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/im-rs-vector-relaxed.csv}\idxseqimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/pvec-rrbvec-balanced.csv}\idxseqpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/pvec-rrbvec-relaxed.csv}\idxseqpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/pvec-std.csv}\idxseqpvecstd;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/rbvec.csv}\idxseqrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/rrbvec.csv}\idxseqrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/std-vec.csv}\idxseqstdvector;

        \pgfplotstableread[col sep=comma]{data/iterator_next/im-rs-vector-balanced.csv}\itrnextimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/iterator_next/im-rs-vector-relaxed.csv}\itrnextimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/iterator_next/pvec-rrbvec-balanced.csv}\itrnextpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/iterator_next/pvec-rrbvec-relaxed.csv}\itrnextpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/iterator_next/pvec-std.csv}\itrnextpvecstd;
        \pgfplotstableread[col sep=comma]{data/iterator_next/rbvec.csv}\itrnextrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/iterator_next/rrbvec.csv}\itrnextrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/iterator_next/std-vec.csv}\itrnextstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
            xticklabels={0, 10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \mega{1}},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Index sequentially},
                legend columns=4,
                legend style={
                    at={(1.12,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\idxseqstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\idxseqrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\idxseqrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\idxseqpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\idxseqpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\idxseqpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\idxseqimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\idxseqimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{} \balanced{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[xmode=log,ymode=log,title={Iterator}]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\itrnextstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\itrnextrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\itrnextrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\itrnextpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\itrnextpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\itrnextpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\itrnextimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\itrnextimrsvectorrelaxed};
        \end{groupplot}

    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmark results of index sequentially and iterator.}
    \label{fig:index-sequentially}
\end{figure}

Unsurprisingly, the \stdvec{} shows the best results in this test. As it is backed by a contiguous chunk of memory, it takes full advantage of CPU cache locality. Besides, its structure is not affected by the method used to build it, when \rbtree{} and \rrbtree{} based vectors are.

Both balanced and unbalanced \imrsvec{} variants tend to be slower in comparison to \rrbvec{} in the \range{[100, \mega{1}]} input range by a factor of 2.06. For smaller inputs, \rrbvec{} it is slightly faster with a difference of 1.18.

\paragraph{Balanced vs. relaxed}
The difference between \rbvec{} and \rrbvec{} becomes noticeable as the problem size grows. The balanced variant is faster than the relaxed one by a factor of 2.68 in the \range{[100, \mega{1}]} input range. This is expected because \rrbvec{} introduces relaxed nodes, which rely on the size tables to compute the path to the value.

This, however, is not the case for small problem sizes in the \range{[0, 100]} range, for which the concatenation algorithm produces a balanced tree. Hence, both balanced and relaxed vectors demonstrate similar performance in that range.

\paragraph{Dynamic representation}
\pvec{} switches its internal representation from the standard vector to \rrbvec{} as soon as cloned. This is evident from the plot \ref{fig:index-sequentially}, where \pvec{} is 4.21 faster than \rbvec{}, but slower than \stdvec{} by a factor of 1.75.

\subsubsection*{Iterator}
Results of the iterator benchmarks show approximately ten-fold improvement in performance over sequential indexing. This is expected, as iterators read the contents of the tree by chunks rather than by index.

\stdvec{} shows the best results, with a difference of 1.98 on average compared to \pvec{}, and 9.12 in relation to \rrbvec{}. \imrsvec{} is 1.47 ahead of \rrbvec{} in the \range{[20, 100]} range.

\paragraph{Balanced vs. relaxed}
As iterator does not use size tables for index calculation for \rrbvec{}, it performs identically well compared to \rbvec{}. The same applies to \imrsvec{}.

\subsubsection*{Index randomly}
\begin{figure}[t]

    \center
    \begin{tikzpicture}
        \pgfplotstableread[col sep=comma]{data/index_randomly/im-rs-vector-balanced.csv}\imrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/index_randomly/im-rs-vector-relaxed.csv}\imrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_randomly/pvec-std.csv}\pvecstd;
        \pgfplotstableread[col sep=comma]{data/index_randomly/pvec-rrbvec-balanced.csv}\pvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_randomly/pvec-rrbvec-relaxed.csv}\pvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_randomly/rbvec.csv}\rbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_randomly/rrbvec.csv}\rrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_randomly/std-vec.csv}\stdvector;

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title={Index randomly},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
            legend pos=north west,
            legend style={draw=none,fill=none,font=\footnotesize},
            legend cell align=left,
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}, \kilo{400}},
        ]
            \addplot[thin, color=morange, mark=*,] table {\stdvector};
            \addlegendentry{\stdvec{}}

            \addplot[thin, color=mred, mark=*,] table {\rbvecbalanced};
            \addlegendentry{\rbvec{}}

            \addplot[thin, color=mred, mark=pentagon,] table {\rrbvecrelaxed};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot[thin, color=mgreen, mark=*,] table {\pvecstd};
            \addlegendentry{\pvec{} \standard{}}

            \addplot[thin, color=mgreen, mark=square,] table {\pvecbalanced};
            \addlegendentry{\pvec{} \balanced{}}

            \addplot[thin, color=mgreen, mark=diamond*,] table {\pvecrelaxed};
            \addlegendentry{\pvec{} \relaxed{}}

            \addplot[thin, color=mpurple, mark=pentagon*,] table {\imrsvectorbalanced};
            \addlegendentry{\imrsvec{}}

            \addplot[thin, color=mpurple, mark=square,] table {\imrsvectorrelaxed};
            \addlegendentry{\imrsvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \caption{Benchmarking results of indexing randomly.}
    \label{fig:index-randomly}
\end{figure}

% > =================================================================================
In this benchmark, values will be read at random positions. Thus, it is quite likely that desired values will be located far apart in memory, potentially causing a cache invalidation. Additionally, results will show whether the performance degenerates with randomness, as it would with linked lists, for example.

By iterating \n{} times, a value is accessed at random index, which is generated within the \range{[0, N)} range by using the \crate{rand} crate\footnote{A Rust library for random number generation: \url{https://crates.io/crates/rand}}. According to the \crate{rand} documentation, generated indices are uniformly distributed. The number generator is explicitly seeded to produce the same stream of randomness between runs.
% < =================================================================================

A noticeable difference compared to the sequential benchmark is that the performance gap between \pvec{} and \stdvec{} is reduced from 1.76 to 1.14. The reason why \stdvec{} has lost its advantage is because of the frequent cache invalidation on access to random memory locations.

\paragraph{Balanced vs. relaxed}
\rbvec{} outperforms \rrbvec{} by 1.90 in the \range{[100, \mega{1}]} range. Both \rrbvec{} and \imrsvec{} are equally fast with insignificant marginal differences.

\paragraph{Dynamic representation}
It is clear that \pvec{}, when flat, is marginally slower compared to \stdvec{}. The performance difference remains consistent over the input range at 1.75.

\subsection{Updating}

% > =================================================================================
There are two dimensions in which the update operation will be evaluated. The first one, similar to the index operation, is the order in which vector values are updated: sequential and random. The second dimension introduces the clone operation used to reveal the cost of copying.

The benchmark list:
\begin{itemize}
    \item Sequentially, with and without \emph{clone}
    \item At random positions, with and without \emph{clone}
\end{itemize}

The setup routine for all benchmarks is identical. As for the index benchmarks, it generates both balanced and relaxed variants of the tree-based vectors. The type of inserted values is an unsigned 64-bit integer.

The vector size is determined by the benchmark argument. The problem size domain for tests using clone is \range{[20, \kilo{20}]}, which is smaller compared to the \range{[20, \kilo{100}]} range, used for benchmarks without clone. This is done to reduce the runtime of benchmarks.

\paragraph{The cost of naive clone vs. path copying}
One of the claimed advantages of \rbvec{} over \stdvec{}, is the cheap clone operation enabled by the path copying algorithm of \rbtree{}. \pvec{} takes advantage of that by switching from the flat to the tree-based representation when cloned. Hence, the objectives are:
\begin{itemize}
    \item Compare performance of naive and path copying algorithms.
    \item Evaluate the efficiency of dynamic representation in \pvec{}.
\end{itemize}

\paragraph{The overhead of relaxed nodes in \rrbtree{}}
Relaxed nodes of \rrbtree{} use size tables to keep track of the size of its child nodes. Balanced nodes, on the other hand, do not need them, as the size can be derived from the node level. Thus, relaxed nodes are more expensive to clone. Additionally, \rrbtree{} is not perfectly balanced as \rbtree{}, potentially resulting in taller trees. The results will reveal how significant this overhead is in practice.

\paragraph{Extending benchmarks with the clone operation}
The test with clone introduces an additional variable for keeping track of the cloned vector. This is done to ensure that at least two vector instances exist simultaneously when the update is executed. This is necessary because \rc{} pointers used to implement \rbtree{}, clone the underlying value on mutation only when the reference count is bigger than one. Thus, by having a cloned instance of vector present in the scope, we enforce the path copying algorithm to be used when updating a vector.
% < =================================================================================

Results of the update operation benchmarks are divided by sequential and random access, and complemented with evaluation with the use of clone operation.

\subsubsection*{Update sequentially}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/update/im-rs-vector-balanced.csv}\upimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update/im-rs-vector-relaxed.csv}\upimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update/pvec-std.csv}\uppvecstd;
        \pgfplotstableread[col sep=comma]{data/update/pvec-rrbvec-balanced.csv}\uppvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update/pvec-rrbvec-relaxed.csv}\uppvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update/rbvec.csv}\uprbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update/rrbvec.csv}\uprrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update/std-vec.csv}\upstdvector;

        \pgfplotstableread[col sep=comma]{data/update_clone/im-rs-vector-balanced.csv}\upclimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone/im-rs-vector-relaxed.csv}\upclimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone/pvec-std.csv}\upclpvecstd;
        \pgfplotstableread[col sep=comma]{data/update_clone/pvec-rrbvec-balanced.csv}\upclpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone/pvec-rrbvec-relaxed.csv}\upclpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone/rbvec.csv}\upclrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone/rrbvec.csv}\upclrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone/std-vec.csv}\upclstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update sequentially},
                yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}},
                legend columns=4,
                legend style={
                    at={(1.06,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\uprbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\uprrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\uppvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\uppvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\uppvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{} \balanced{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update sequentially and cloning},
                yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
                xticklabels={0, 100, \kilo{1}, \kilo{10}},
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upclstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\upclrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\upclrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\upclpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\upclpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\upclpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upclimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upclimrsvectorrelaxed};
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of updating values sequentially.}
    \label{fig:update-sequentially}
\end{figure}

% > =================================================================================
The test function iterates over indices in the \range{[0, N)} range, where \n{} is the problem size, acquiring a mutable reference to the value at the given position. Once the reference is acquired, it is used to increment the value.
% < =================================================================================

\stdvec{} is the fastest vector in the sequential updates test, with the closest runner-up being \pvec{} with the mean difference of 2.32. When cloned, however, tree-based types, such as \rbvec{}, start outperforming the standard vector after surpassing the \kilo{4} size. The difference grows quickly, reaching 7.45 at the size of \kilo{20}. It demonstrates how well path copying scales when cloning large data structures.

Updates are slower for \imrsvec{} compared to \rrbvec{} by 2.47 on average. When cloned, however, the difference is less significant, varying mostly in the range of \range{[20, 400]}.

\paragraph{Balanced vs. relaxed}
Relaxed nodes and size tables associated with them were expected to have a negative impact on the performance when copying. Though, the numbers in the clone test do not confirm that assumption. However, if updated without cloning, \rrbvec{} is slower than \rbvec{} by 1.33.

\paragraph{Dynamic representation}
When updating a vector, \pvec{} is faster than both variants of \rbvec{} by a factor of 2.22 on average. It is, however, slower than \stdvec{}, even though the standard vector is used as a representation. It is expected that \pvec{} will introduce some overhead, as essentially, it introduces an additional abstraction layer.

\subsubsection*{Update randomly}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/update_randomly/im-rs-vector-balanced.csv}\upimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update_randomly/im-rs-vector-relaxed.csv}\upimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_randomly/pvec-std.csv}\uppvecstd;
        \pgfplotstableread[col sep=comma]{data/update_randomly/pvec-rrbvec-balanced.csv}\uppvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_randomly/pvec-rrbvec-relaxed.csv}\uppvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_randomly/rbvec.csv}\uprbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_randomly/rrbvec.csv}\uprrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_randomly/std-vec.csv}\upstdvector;

        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/im-rs-vector-balanced.csv}\upclimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/im-rs-vector-relaxed.csv}\upclimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/pvec-std.csv}\upclpvecstd;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/pvec-rrbvec-balanced.csv}\upclpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/pvec-rrbvec-relaxed.csv}\upclpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/rbvec.csv}\upclrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/rrbvec.csv}\upclrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/std-vec.csv}\upclstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update randomly},
                legend columns=4,
                legend style={
                    at={(1.06,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\uprbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\uprrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\uppvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\uppvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\uppvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{} \balanced{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update randomly and cloning},
                yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
                xticklabels={0, 100, \kilo{1}, \kilo{10}},
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upclstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\upclrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\upclrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\upclpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\upclpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\upclpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upclimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upclimrsvectorrelaxed};
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of updating values randomly.}
    \label{fig:update-randomly}
\end{figure}

% > =================================================================================
The test function contains a loop, which is executed \n{} times. In the loop body, value is updated by incrementing it, at the index that is randomly generated in the \range{[0, N)} range.
% < =================================================================================

As with indexing, when values are updated randomly rather than sequentially, the performance gap between the \stdvec{} and \pvec{} became as small as 1.11 due to the frequent cache invalidations caused by random access. Other than that, there are no significant distinctions.

\subsection{Pushing}
% > =================================================================================
The push operation is evaluated by populating an empty and existing vectors. Both tests are also extended with the clone operation.

\paragraph{The overhead of relaxed nodes in \rrbtree{}}
The push operation is responsible for increasing the vector capacity. While the vector capacity calculation for \rrbtree{} relies on the size tables, for \rbtree{}, it is sufficient to know the level of the node and the branching factor. Additionally, instantiating relaxed nodes implies the allocation of size tables. All these factors combined are expected to make \rrbtree{}'s push slower compared to \rbtree{}. Thus, there is a dedicated benchmark that uses prebuilt, \rrbtree{}, and \rbtree{} based vectors to evaluate the difference.

\paragraph{Extending benchmarks with the clone operation}
To force \pvec{} to switch from \stdvec{} to \rrbvec{}, several preconditions have to be met, including the reference count being bigger than 1. Hence, the benchmarks above are extended to use clone, in the same way as for benchmarks of the update operation. Beyond the evaluation of \pvec{}, the results are expected to reveal how tree-based vectors stack up to \stdvec{}. The input range for benchmarks using clone is \range{[20, \kilo{40}]}.
% < =================================================================================

Benchmarks are divided into two use cases:
\begin{itemize}
    \item Building a new vector from scratch by pushing values into it.
    \item Pushing values into an existing vector, both balanced and relaxed.
\end{itemize}

Both benchmarks are extended using the clone operation.

\subsubsection*{Building a vector}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/push/im-rs-vector-balanced.csv}\pushimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push/pvec-std.csv}\pushpvecstd;
        \pgfplotstableread[col sep=comma]{data/push/rbvec.csv}\pushrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push/std-vec.csv}\pushstdvector;

        \pgfplotstableread[col sep=comma]{data/push_clone/im-rs-vector-balanced.csv}\pushclnimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone/pvec-rrbvec-balanced.csv}\pushclnpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone/rbvec.csv}\pushclnrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone/std-vec.csv}\pushclnstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \mega{1}},
            yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Building a new vector},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushrbvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\pushpvecstd};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushimrsvectorbalanced};
            \legend{\stdvec{}, \rbvec{}, \pvec{} \standard{}, \imrsvec{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Building a new vector and cloning it.},
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}},
                yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushclnstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushclnrbvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\pushclnpvecbalanced};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushclnimrsvectorbalanced};
            \legend{\stdvec{}, \rbvec{}, \pvec{}, \imrsvec{}}
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of push.}
    \label{fig:push}
\end{figure}

% > =================================================================================
As vector is built from scratch in this benchmark, there is no need for a setup routine. The test function runs a loop over the \range{[0, N)} range of indices, and pushes the index as a value into a vector. The problem size range is \range{[20, \mega{1}]}.
% < =================================================================================

When building a vector in the \range{[20, 100]} range, tree-based types are slightly faster than \stdvec{}, as they take advantage of the tail optimization.

\imrsvec{} is almost as fast as \rbvec{} with a difference of 1.18. When cloned, however, \rbvec{} outperforms it by a significant amount of 3.61.

In the cloning benchmark, persistent vectors once more demonstrate how effective they are when copied, by \rbvec{} being faster than \stdvec{} by a staggering factor of 12.85.

\paragraph{Dynamic representation}
Overall, \pvec{} is the fastest vector, mostly due to the combination of using \stdvec{} with the pre-allocated space\footnote{\pvec{} is initialized to the capacity of branching factor, that is 32 in the test configuration.} for small sizes. Closer to the end of the size range, \stdvec{} and \pvec{} align in performance with the average difference of 1.27.

When cloned, \pvec{} is losing only to \rbvec{} by in-significant 1.35, demonstrating the effectiveness of the dynamic representation.

\subsubsection*{Adding values to an existing vector}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/push_relaxed/im-rs-vector-balanced.csv}\pushimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/im-rs-vector-relaxed.csv}\pushimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/pvec-std.csv}\pushpvecstd;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/pvec-rrbvec-balanced.csv}\pushpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/pvec-rrbvec-relaxed.csv}\pushpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/rbvec.csv}\pushrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/rrbvec.csv}\pushrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/std-vec.csv}\pushstdvector;

        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/im-rs-vector-balanced.csv}\pushclnimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/im-rs-vector-relaxed.csv}\pushclnimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/pvec-rrbvec-balanced.csv}\pushclnpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/pvec-rrbvec-relaxed.csv}\pushclnpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/rbvec.csv}\pushclnrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/rrbvec.csv}\pushclnrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/std-vec.csv}\pushclnstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Adding values to an existing vector},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\pushrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\pushpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\pushpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\pushpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\pushimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{20}},
                yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
                title={Adding values to an existing vector and cloning it},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushclnstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushclnrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\pushclnrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\pushclnpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\pushclnpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushclnimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\pushclnimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of adding values to an existing vector.}
    \label{fig:push-existing}
\end{figure}

% > =================================================================================
Push operation does not produce relaxed nodes in balanced trees. Hence, there is no way to evaluate the impact of relaxation in the benchmark of building a vector from scratch. Thus, in this benchmark, values are added to an existing vector, where vector can be both balanced and relaxed depending on the setup routine.

Objectives of the benchmark are:
\begin{itemize}
    \item Check the cost of the complex sub-tree capacity and index computation.
    \item Measure the overhead of using size tables when cloning relaxed nodes.
\end{itemize}

The setup routine generates a vector of the fixed size of \n{} and passes it to the test function. The balanced, \rbtree{} based vector is created by pushing values directly into it, while the \rrbtree{} based one, is created by concatenating several vectors together. Once a vector is created, the test function pushes \n{} values onto it.
% < =================================================================================

Even though size tables increase the size of the node and add complexity to the implementation, both relaxed and balanced trees show nearly identical performance in this test.

When push is called continuously, even for relaxed nodes, only balanced nodes are added to the tree. Eventually, all new nodes at the end of the tree, except the root, will be balanced. Thus, there is nearly no overhead of running push over a relaxed \rrbvec{} in the given benchmarks.

\subsection{Popping}

\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/pop/im-rs-vector-balanced.csv}\popimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/pop/im-rs-vector-relaxed.csv}\popimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop/pvec-std.csv}\poppvecstd;
        \pgfplotstableread[col sep=comma]{data/pop/pvec-rrbvec-balanced.csv}\poppvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop/pvec-rrbvec-relaxed.csv}\poppvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop/rbvec.csv}\poprbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop/rrbvec.csv}\poprrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop/std-vec.csv}\popstdvector;

        \pgfplotstableread[col sep=comma]{data/pop_clone/im-rs-vector-balanced.csv}\popclnimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/pop_clone/im-rs-vector-relaxed.csv}\popclnimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop_clone/pvec-std.csv}\popclnpvecstd;
        \pgfplotstableread[col sep=comma]{data/pop_clone/pvec-rrbvec-balanced.csv}\popclnpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop_clone/pvec-rrbvec-relaxed.csv}\popclnpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop_clone/rbvec.csv}\popclnrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop_clone/rrbvec.csv}\popclnrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop_clone/std-vec.csv}\popclnstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{60}},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Popping values from a vector},
                legend columns=4,
                legend style={
                    at={(1.12,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\popstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\poprbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\poprrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\poppvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\poppvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\poppvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\popimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\popimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}},
                yticklabels={0, \micros{1}, 0.01, 0.1, 1, 10, 100},
                title={Popping values from a vector and cloning it},
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\popclnstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\popclnrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\popclnrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\popclnpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\popclnpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\popclnpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\popclnimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\popclnimrsvectorrelaxed};
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of popping values.}
    \label{fig:pop}
\end{figure}
% > =================================================================================
The pop operation manages the vector capacity as well as push. For \stdvec{}, it means shrinking the array and copying elements over. For tree-based vectors, it implies de-allocating nodes and reducing the height of the tree when necessary.

The benchmark is divided into two tests, namely pop and pop clone. The first test calls pop continuously in the loop until the vector is emptied, with the problem size range of \range{[20, \kilo{60}]}.

In the second benchmark, each pop operation will be followed by a clone. Both tests include balanced and relaxed vector types, which are prepared in the setup routine. The problem size range is \range{[20, \kilo{40}]}.

\paragraph{The overhead of relaxed nodes in \rrbtree{}}
Lowering the height of \rrbtree{} involves the tree capacity calculation using size tables, that comes at an additional cost. Thus, this test includes both balanced and relaxed variants of vectors.
% < =================================================================================

In the test without clone, \imrsvec{} is slightly faster than \rbvec{} and \rrbvec{} by 1.29. The difference between balanced and relaxed trees is only 1.02, showing that the cost of managing the relaxed tree capacity is not expensive.

\pvec{} is the second fastest vector with \stdvec{} being 1.99 faster on average. When cloned, \pvec{} switches the representation and becomes as fast as \rbvec{}.

On the other hand, \imrsvec{} is the slowest tree-based vector when cloned, but still faster than \stdvec{}, especially for large sizes.

\subsection{Appending}

\begin{figure}[t]

    \center
    \begin{tikzpicture}
        \pgfplotstableread[col sep=comma]{data/append/im-rs-vector-relaxed.csv}\imrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/append/pvec-std.csv}\pvecstd;
        \pgfplotstableread[col sep=comma]{data/append/pvec-rrbvec-relaxed.csv}\pvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/append/rbvec.csv}\rbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/append/rrbvec.csv}\rrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/append/std-vec.csv}\stdvector;

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title={Appending vectors},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \mega{1}},
            yticklabels={0, \micros{1}, 0.01, 0.1, 1, 10},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
            legend pos=north west,
            legend style={draw=none,fill=none,font=\footnotesize},
            legend cell align=left,
        ]
            \addplot[thin, color=morange, mark=*,] table {\stdvector};
            \addlegendentry{\stdvec{}}

            \addplot[thin, color=mred, mark=*,] table {\rbvecbalanced};
            \addlegendentry{\rbvec{}}

            \addplot[thin, color=mred, mark=pentagon,] table {\rrbvecrelaxed};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot[thin, color=mgreen, mark=*,] table {\pvecstd};
            \addlegendentry{\pvec{} \standard{}}

            \addplot[thin, color=mgreen, mark=diamond*,] table {\pvecrelaxed};
            \addlegendentry{\pvec{} \relaxed{}}

            \addplot[thin, color=mpurple, mark=square,] table {\imrsvectorrelaxed};
            \addlegendentry{\imrsvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \caption{Benchmarking results of appending vectors.}
    \label{fig:append}
\end{figure}

% > =================================================================================
The append operation merges contents of one vector into another. One of the advantages of \rrbtree{} is the relatively low cost of append, that is \bigo{(m^2 \cdot log_m(n)}, in comparison to \bigo{max(a,b)} of \stdvec{}. The objective is to confirm this assumption experimentally.

\paragraph{Naive vs. relaxed append algorithm}
The \rbtree{}-based vector uses a naive concatenation algorithm that moves values from one vector to another. \rrbtree{}, on the other hand, merges and re-balances two trees, which is faster in theory. Due to the hardware design specifics, this might not be true for all vector sizes. Thus, benchmarks will reveal how different algorithms perform depending on the size of concatenated vectors.

\paragraph{Appending vectors}
The setup routine prepares a collection of vectors, where each consecutive vector is bigger than the previous. The total size of all prepared vectors adds up to the problem size \n{}. The benchmark is parameterized over the vector size, which will be in the \range{[20, \mega{1}]} range.

Each vector is created by a combination of append and push operations. This way \pvec{} and \rrbvec{} will be forced to use \rrbtree{} for internal representation, while \rbvec{} will remain balanced. \stdvec{} remains flat and does not depend on the type of operation used to add values to it.

The benchmark function iterates over generated vectors and appends them into a vector defined as a local variable.
% < =================================================================================

Based on the results, the naive copying of \stdvec{} is the fastest concatenation algorithm up to the problem size of \kilo{40}. However, after surpassing \kilo{40} it quickly degenerates and loses to \rrbvec{} by 6.53, with a maximum difference of 12.85 for the size of \mega{1}.

Even though not for all input sizes, we can see that \rrbvec{}'s concatenation algorithm scales better and eventually outperforms \stdvec{}.

\imrsvec{} catches up to \stdvec{} only at the size of \kilo{400}, still being slower than \rrbvec{} by 1.29 at that point.

\paragraph{Balanced vs. relaxed}
For the input size up to \kilo{2}, \rbvec{} and \rrbvec{} show similar results. The simplicity of naive concatenation used by \rbvec{} is sufficient to be as fast as \rrbvec{} due to the small problem size.

This, however, drastically changes after the \kilo{2} size, where \rbvec{} continuously degrades, showing the worst results among all vectors. The performance difference between \rbvec{} and \rrbvec{} at the size of \mega{1} is staggering 145.59.

As for \pvec{}, it follows the curves of \stdvec{} and \rrbvec{} because of the dynamic representation, as expected.

\subsection{Splitting}

\begin{figure}[t]

    \center
    \begin{tikzpicture}
        \pgfplotstableread[col sep=comma]{data/split_off/im-rs-vector-relaxed.csv}\imrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/split_off/pvec-std.csv}\pvecstd;
        \pgfplotstableread[col sep=comma]{data/split_off/pvec-rrbvec-relaxed.csv}\pvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/split_off/rbvec.csv}\rbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/split_off/rrbvec.csv}\rrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/split_off/std-vec.csv}\stdvector;

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title={Splitting vectors},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 100, \kilo{1}, \kilo{10}, \kilo{100}, \kilo{400}},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100, \seconds{1}, \seconds{10}},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
            legend pos=north west,
            legend style={draw=none,fill=none,font=\footnotesize},
            legend cell align=left,
        ]
            \addplot[thin, color=morange, mark=*,] table {\stdvector};
            \addlegendentry{\stdvec{}}

            \addplot[thin, color=mred, mark=*,] table {\rbvecbalanced};
            \addlegendentry{\rbvec{}}

            \addplot[thin, color=mred, mark=pentagon,] table {\rrbvecrelaxed};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot[thin, color=mgreen, mark=*,] table {\pvecstd};
            \addlegendentry{\pvec{} \standard{}}

            \addplot[thin, color=mgreen, mark=diamond*,] table {\pvecrelaxed};
            \addlegendentry{\pvec{} \relaxed{}}

            \addplot[thin, color=mpurple, mark=square,] table {\imrsvectorrelaxed};
            \addlegendentry{\imrsvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \caption{Benchmarking results of splitting vectors.}
    \label{fig:split}
\end{figure}

% > =================================================================================
The split operation slices a vector into two parts at the given index. The \rrbtree{}'s algorithm theoretically can achieve good performance by avoiding unnecessary copying. However, due to its complexity, it might be outperformed by naive copying for small-sized vectors.

\paragraph{Splitting vectors}
The test itself anticipates a prepared vector, which is generated in the setup routine. To evaluate both balanced and relaxed variants, it generates them either by using appending or pushing. The vector sizes are within \range{[128, \kilo{200}]}.

Once a vector is generated, the benchmark function enters the loop with the condition that the vector needs to contain more than 64 elements. In the loop, a vector is split at index 64, the result of which is assigned back to a variable. Essentially, a vector is being truncated at the front by 64 elements, until it is small enough for the loop to exit.
% < =================================================================================


% TODO: you have to be open about:
%  1: split_off and append are fast*er* compared to vec only for large sizes
%   1.1: this is part of the reason why in par benchmarks tree-based vectors suck
%  2: split_off benchmark is biased as it favors the use-case that is faster for the tree-based implementations

The performance advantage of \stdvec{} over \rrbvec{} is 3.24 up to the size of \kilo{20}, after which it degrades and gets slower than \imrsvec{} and \rrbvec{} by 5.95. The difference is more significant for \rbvec{} at the factor of 65.65 for the size of \kilo{400}.

% NOTE: this can go under the summary part of the 
%  section, rather than being its own sub-section
\subsection{Rc vs Arc}
\label{sec:perf-rc-vs-arc}
\todo{Execute sequential benchmarks using \arc{} pointer}
\stdvec{} is not included in the comparison, as its implementation does not rely on the reference counted pointers.

\section{Parallel benchmark results}
\label{sec:par-benchmarks}

% > =================================================================================
\subsection*{Computation stages}
The parallel benchmarks for this project are executed in three stages:
\begin{enumerate}
    \item Split the work into tasks between threads.
    \item Process the tasks.
    \item Combine and return the results.
\end{enumerate}

% TODO: you haven't really described how results are collected, and what are Fold and Reduce combinators.
% TODO: throwing a snippet in won't help.
The third step can be either of two:
\begin{itemize}
    \item Collect individual items into a vector using the parallel \emph{Fold} combinator.
    \item Reduce emitted vectors into a single one using the \emph{Reduce} combinator.
\end{itemize}

\begin{figure}[!htbp]
    \centering

    \begin{minted}{rust}
        let result = parallel_iterator
            .fold(Vec::new, |mut vec, x| {
                vec.push(x);
                vec
            })
            .reduce(Vec::new, |mut vec1, mut vec2| {
                vec1.append(&mut vec2);
                vec1
            });
    \end{minted}

    \caption{Collecting items of parallel iterator.}
    \label{fig:fold-reduce}
\end{figure}
% < =================================================================================

% > =================================================================================
The benchmarks were executed against \stdvec{} and vectors from \pvecrs{}, where \rbvec{}, \rrbvec{}, and \pvec{} were compiled with the threadsafe reference-counted pointer -- \arc{}.

As of the time of writing, \imrsvec{} does not implement the Rayon's \emph{IntoParallelIterator} trait. Since all other tested vectors rely on it, the decision was made not to include \imrsvec{} in the parallel benchmarks to avoid the unfair comparison.

Benchmarks were parameterized over two dimensions: the vector size and the number of threads. To see whether parallelism is beneficial, each benchmark has an analogous, sequential implementation used as the baseline.
% < =================================================================================

The results present the overall vector performance across several operations in the parallel context to check the following:
\begin{itemize}
    \item Scalability of the tree-based vectors.
    \item The impact of the relaxed append and split operations.
\end{itemize}

The results are presented in the form of a three-dimensional graph, where x and y-axis correspond to the problem size and number of used threads, while z stands for the mean runtime.

\subsection{Adding elements of two vectors.}

\begin{figure}[!htbp]

    \center
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\footnotesize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title style={align=center},
            title={Adding elements of two \n{} sized vectors\\ parallelized on \emph{K} number of threads.},
            ymajorgrids=true,
            xmajorgrids=true,
            zmajorgrids=true,
            xlabel={Vector size (log scale)},
            ylabel={Number of threads (log scale)},
            zlabel={Mean time (log scale) [\millis{}]},
            xticklabels={10, 100, \kilo{1}, \kilo{10}},
            ytick={1, 2, 4, 8},
            yticklabels={1, 2, 4, 8},
            zticklabel style={
                /pgf/number format/fixed,
                /pgf/number format/precision=2
            },
            zticklabel={%
                \pgfmathfloatparsenumber{\tick}%
                \pgfmathfloatexp{\pgfmathresult}%
                \pgfmathprintnumber{\pgfmathresult}%
            },
            grid style=dashed,
            legend pos=outer north east,
            legend style={fill=none,font=\footnotesize},
            legend cell align=left,
            view={-45}{8},
        ]
            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mred] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/std-vec.csv};
            \addlegendentry{\stdvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=morange] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/rbvec-balanced.csv};
            \addlegendentry{\rbvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=blue] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/rrbvec-relaxed.csv};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mgreen] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/pvec-relaxed.csv};
            \addlegendentry{\pvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \label{fig:adding-two-vectors-par}
    \caption{Adding elements of two \n{} sized vectors parallelized on \emph{K} number of threads.}
\end{figure}

% > =================================================================================
Given two equally sized vectors of integers, the test function adds values at the corresponding indices and returns a new instance of a vector with results. The benchmark is subdivided into three steps:

\begin{enumerate}
    \item Transform two vectors into a single sequence of value pairs by merging their parallel iterators.
    \item Add values of the emitted value pair into a single integer.
    \item Reduce individual sums into a vector of results.
\end{enumerate}

The setup routine prepares two vectors of integers in the \range{[0, N]} problem size range.
% < =================================================================================

\rbvec{} and \rrbvec{} show nearly identical results in sequential benchmarks. This is expected, as append and split operations that create relaxed nodes were not used. Hence, \rrbvec{} remains balanced throughout the test, and is backed by the same representation of \rrbtree{} as \rbvec{}. Both variants are consistently slower compared to \stdvec{}, with a difference of 3.2-3.5 on average.

When executed in parallel, \rrbvec{} starts outperforming \rbvec{} at the size of 1024 elements. The reason why difference becomes apparent after surpassing that size is that the concatenation algorithm used in this project produces balanced \rbtree{} when the height of the tree does not exceed two levels. With the branching factor of 32, the capacity of the tree of two levels is equal to 1024.

As the vector size grows, Rayon performs more slices to achieve optimal vector size per a single thread. This, in turn, results in a higher number of concatenations necessary to combine execution results. Since \rbvec{} has the naive implementation of append and split, its performance degrades with the input size growth. The difference in execution time, depending on size falls into the 1.0-2.3 range.

To keep available threads busy, Rayon divides the available pool of work into smaller pieces. Hence, the growing number of threads increases the performance gap between \rbvec{} and \rrbvec{} even further, as split and append are used more frequently. In the test with 2, 4 and 8 threads, \rbvec{} is slower than \rrbvec{} by a factor of 1.0-2.3, 1.0-2.8, and 1.1-2.12 correspondingly.

Even though \rrbvec{}'s append and split operations are faster for the large-sized vectors, \stdvec{} showed the best results in all tests. It is important to keep in mind that appends and splits constitute only a small number of all operations used in this test. Operations such as push and get, which were extensively used in this benchmark, are still faster for \stdvec{}. Thus, the closest runner up -- \pvec{}, is slower by 1.8-1.9 and 1.6-1.7 in the sequential and 4-threaded parallel benchmarks correspondingly.

\paragraph{Effect of parallelism}
% TODO: this is not entirely true, because 4 threads benchmark runs slightly faster for large datasets compared to sequential bench.
The sequential variant of the benchmark outperformed all subsequent parallel tests. This can be explained by the overhead induced by the distribution of work between multiple threads, which outweighs the benefits of solving a relatively simple problem in parallel.

\subsection{Check if a word is a palindrome}

\begin{figure}[!htbp]

    \center
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\footnotesize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title style={align=center},
            title={Filtering palindromes on \emph{K} number of threads.},
            ymajorgrids=true,
            xmajorgrids=true,
            zmajorgrids=true,
            xlabel={Vector size (log scale)},
            ylabel={Number of threads (log scale)},
            zlabel={Mean time (log scale) [\millis{}]},
            xticklabels={10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \kilo{400}},
            ytick={1, 2, 4, 8},
            yticklabels={1, 2, 4, 8},
            zticklabel style={
                /pgf/number format/fixed,
                /pgf/number format/precision=2
            },
            zticklabel={%
                \pgfmathfloatparsenumber{\tick}%
                \pgfmathfloatexp{\pgfmathresult}%
                \pgfmathprintnumber{\pgfmathresult}%
            },
            grid style=dashed,
            legend pos=outer north east,
            legend style={fill=none,font=\footnotesize},
            legend cell align=left,
            view={-45}{8},
        ]
            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mred] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/std-vec.csv};
            \addlegendentry{\stdvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=morange] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/rbvec-balanced.csv};
            \addlegendentry{\rbvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=blue] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/rrbvec-relaxed.csv};
            \addlegendentry{\rrbvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mgreen] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/pvec-relaxed.csv};
            \addlegendentry{\pvec{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \label{fig:words-filter}
    \caption{Filtering palindromes on \emph{K} number of threads.}
\end{figure}

% > =================================================================================
The benchmark checks whether a word is a palindrome and annotates it with a boolean flag. As input, we are using a list of English words consisting only of alphabetic characters. The computation stages are the following:

\begin{enumerate}
    \item Transform the given vector of words into a parallel iterator.
    \item Return a tuple of the word and the flag indicating if the word is a palindrome.
    \item Reduce the results to a new instance of a vector of tuples.
\end{enumerate}

\paragraph{The benchmark setup}
The dictionary file contains 370103 words. The benchmark is parameterized over the number of threads and words. The data is loaded into memory only once, and before each run, the setup routine copies \n{} words and passes them to the test as a vector.
% < =================================================================================

As expected, \rbvec{} and \rrbvec{} are equally fast in the sequential test, as both of them are backed by a balanced \rbtree{}. When the benchmark is parallelized, \rrbvec{} gains advantage due to its efficient slice and concatenation operations. The difference between variants grows along with the increasing count of threads. Specifically, it is 1.5-2.0 for the test run with two threads, and 1.7-2.5 for four threads.

The increase in the thread count causes a higher count of vector slices and concatenations. Thus, the bigger the problem size and the thread count is, the more advantages \rrbvec{} provides, demonstrating performance results comparable to \stdvec{}.

\section{Memory benchmarks}
% > =================================================================================
The goals for the memory tests are the following:
\begin{itemize}
    \item Measure and compare the memory footprint of the tree-based and standard vectors.
    \item Evaluate the effectiveness of the structural sharing when cloning a vector.
\end{itemize}

\subsubsection*{Building a vector}
This benchmark is expected to reveal the memory overhead of using a tree instead of the contiguous memory block as its height, and the node count grows. Given the size \n{} as a parameter, this benchmark builds a vector by pushing \n{} values into it. The problem size range is \range{[20, 60k]}.

\subsubsection*{Updating and cloning a vector}
The test builds a new vector of size \n{}, runs a loop from 0 to \n{}, clones a vector, and updates a value at the given index. All cloned instances are accumulated in another vector to observe how well structural sharing helps to save memory. The vector sizes are in \range{[20, 60k]} range.
% < =================================================================================
