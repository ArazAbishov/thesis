\newcommand{\balanced}{}
\newcommand{\standard}{\emph{(s)}}
\newcommand{\relaxed}{\emph{(r)}}

\chapter{Results}
In this chapter, we will take a look at the results of the sequential and parallel benchmarks, and discuss whether proposed\todo{ref} performance optimizations are effective.

The sequential benchmark results are subdivided per the core operation and listed under the \ref{sec:perf-seq} section. Performance of the threadsafe implementation is evaluated separately.

The parallel benchmark results in section \ref{sec:perf-par} are not discussed by operation, as they focus on the overall performance comparison of vectors rather than particular operation in isolation.

The results are discussed to address the following points:
\begin{itemize}
    \item Effect of \rrbtree{} relaxation on concatenation, splitting, and other core operations of \rrbvec{} and \pvec{}.
    \item The impact of the unique access optimization on the performance of all vector implementations.
    \item Effectiveness of the dynamic representation.
\end{itemize}

\paragraph{Reading notes}
Implementations that are prefixed with \relaxed{} in the figure legend were configured to use the relaxed \emph{rb} tree in the benchmark. \standard{} stands for standard and will be applied only to \pvec{} when it is flat. If not specified, the vector is backed by the balanced \rbtree{}.

\section{Sequential benchmark results}
\label{sec:perf-seq}
This section contains performance numbers for the non-threadsafe implementations of \stdvec{}, \rbvec{}, \rrbvec{}, \pvec{}, and \imrsvec{}. Threadsafe variants are evaluated and discussed separately in section \ref{sec:perf-rc-vs-arc}.

\subsection{Indexing}
Figures for the index operation are separated by sequential and random access, where the sequential benchmark results are subdivided into the index and iterator figures.

\subsubsection*{Index sequentially}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/index_sequentially/im-rs-vector-balanced.csv}\idxseqimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/im-rs-vector-relaxed.csv}\idxseqimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/pvec-rrbvec-balanced.csv}\idxseqpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/pvec-rrbvec-relaxed.csv}\idxseqpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/pvec-std.csv}\idxseqpvecstd;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/rbvec.csv}\idxseqrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/rrbvec.csv}\idxseqrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_sequentially/std-vec.csv}\idxseqstdvector;

        \pgfplotstableread[col sep=comma]{data/iterator_next/im-rs-vector-balanced.csv}\itrnextimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/iterator_next/im-rs-vector-relaxed.csv}\itrnextimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/iterator_next/pvec-rrbvec-balanced.csv}\itrnextpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/iterator_next/pvec-rrbvec-relaxed.csv}\itrnextpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/iterator_next/pvec-std.csv}\itrnextpvecstd;
        \pgfplotstableread[col sep=comma]{data/iterator_next/rbvec.csv}\itrnextrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/iterator_next/rrbvec.csv}\itrnextrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/iterator_next/std-vec.csv}\itrnextstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
            xticklabels={0, 10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \mega{1}},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Index sequentially},
                legend columns=4,
                legend style={
                    at={(1.12,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\idxseqstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\idxseqrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\idxseqrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\idxseqpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\idxseqpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\idxseqpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\idxseqimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\idxseqimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{} \balanced{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[xmode=log,ymode=log,title={Iterator}]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\itrnextstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\itrnextrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\itrnextrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\itrnextpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\itrnextpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\itrnextpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\itrnextimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\itrnextimrsvectorrelaxed};
        \end{groupplot}

    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmark results of index sequentially and iterator.}
    \label{fig:index-sequentially}
\end{figure}

Unsurprisingly, the \stdvec{} shows the best results in this test. As it is backed by a contiguous chunk of memory, it takes full advantage of CPU cache locality. Besides, its structure is not affected by the method used to build it, when \rbtree{} and \rrbtree{} based vectors are.

Both balanced and unbalanced \imrsvec{} variants tend to be slower in comparison to \rrbvec{} in the \range{[100, \mega{1}]} input range by a factor of 2.06. For smaller inputs, \rrbvec{} it is slightly faster with a difference of 1.18.

\paragraph{Balanced vs. relaxed}
The difference between \rbvec{} and \rrbvec{} becomes noticeable as the problem size grows. The balanced variant is faster than the relaxed one by a factor of 2.68 in the \range{[100, \mega{1}]} input range. This is expected because \rrbvec{} introduces relaxed nodes, which rely on the size tables to compute the path to the value.

This, however, is not the case for small problem sizes in the \range{[0, 100]} range, for which the concatenation algorithm produces a balanced tree. Hence, both balanced and relaxed vectors demonstrate similar performance in that range.

\paragraph{Dynamic representation}
\pvec{} switches its internal representation from the standard vector to \rrbvec{} as soon as cloned. This is evident from the plot \ref{fig:index-sequentially}, where \pvec{} is 4.21 faster than \rbvec{}, but slower than \stdvec{} by a factor of 1.75.

\subsubsection*{Iterator}
Results of the iterator benchmarks show approximately ten-fold improvement in performance over sequential indexing. This is expected, as iterators read the contents of the tree by chunks rather than by index.

\stdvec{} shows the best results, with a difference of 1.98 on average compared to \pvec{}, and 9.12 in relation to \rrbvec{}. \imrsvec{} is 1.47 ahead of \rrbvec{} in the \range{[20, 100]} range.

\paragraph{Balanced vs. relaxed}
As iterator does not use size tables for index calculation for \rrbvec{}, it performs identically well compared to \rbvec{}. The same applies to \imrsvec{}.

\subsubsection*{Index randomly}
\begin{figure}[t]

    \center
    \begin{tikzpicture}
        \pgfplotstableread[col sep=comma]{data/index_randomly/im-rs-vector-balanced.csv}\imrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/index_randomly/im-rs-vector-relaxed.csv}\imrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_randomly/pvec-std.csv}\pvecstd;
        \pgfplotstableread[col sep=comma]{data/index_randomly/pvec-rrbvec-balanced.csv}\pvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_randomly/pvec-rrbvec-relaxed.csv}\pvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_randomly/rbvec.csv}\rbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/index_randomly/rrbvec.csv}\rrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/index_randomly/std-vec.csv}\stdvector;

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title={Index randomly},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
            legend pos=north west,
            legend style={draw=none,fill=none,font=\footnotesize},
            legend cell align=left,
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}, \kilo{400}},
        ]
            \addplot[thin, color=morange, mark=*,] table {\stdvector};
            \addlegendentry{\stdvec{}}

            \addplot[thin, color=mred, mark=*,] table {\rbvecbalanced};
            \addlegendentry{\rbvec{}}

            \addplot[thin, color=mred, mark=pentagon,] table {\rrbvecrelaxed};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot[thin, color=mgreen, mark=*,] table {\pvecstd};
            \addlegendentry{\pvec{} \standard{}}

            \addplot[thin, color=mgreen, mark=square,] table {\pvecbalanced};
            \addlegendentry{\pvec{} \balanced{}}

            \addplot[thin, color=mgreen, mark=diamond*,] table {\pvecrelaxed};
            \addlegendentry{\pvec{} \relaxed{}}

            \addplot[thin, color=mpurple, mark=pentagon*,] table {\imrsvectorbalanced};
            \addlegendentry{\imrsvec{}}

            \addplot[thin, color=mpurple, mark=square,] table {\imrsvectorrelaxed};
            \addlegendentry{\imrsvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \caption{Benchmarking results of indexing randomly.}
    \label{fig:index-randomly}
\end{figure}

A noticeable difference compared to the sequential benchmark is that the performance gap between \pvec{} and \stdvec{} is reduced from 1.76 to 1.14. The reason why \stdvec{} has lost its advantage is because of the frequent cache invalidation on access to random memory locations.

\paragraph{Balanced vs. relaxed}
\rbvec{} outperforms \rrbvec{} by 1.90 in the \range{[100, \mega{1}]} range. Both \rrbvec{} and \imrsvec{} are equally fast with insignificant marginal differences.

\paragraph{Dynamic representation}
It is clear that \pvec{}, when flat, is marginally slower compared to \stdvec{}. The performance difference remains consistent over the input range at 1.75.

\subsection{Updating}
Results of the update operation benchmarks are divided by sequential and random access, and complemented with evaluation with the use of clone operation.

\subsubsection*{Update sequentially}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/update/im-rs-vector-balanced.csv}\upimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update/im-rs-vector-relaxed.csv}\upimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update/pvec-std.csv}\uppvecstd;
        \pgfplotstableread[col sep=comma]{data/update/pvec-rrbvec-balanced.csv}\uppvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update/pvec-rrbvec-relaxed.csv}\uppvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update/rbvec.csv}\uprbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update/rrbvec.csv}\uprrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update/std-vec.csv}\upstdvector;

        \pgfplotstableread[col sep=comma]{data/update_clone/im-rs-vector-balanced.csv}\upclimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone/im-rs-vector-relaxed.csv}\upclimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone/pvec-std.csv}\upclpvecstd;
        \pgfplotstableread[col sep=comma]{data/update_clone/pvec-rrbvec-balanced.csv}\upclpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone/pvec-rrbvec-relaxed.csv}\upclpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone/rbvec.csv}\upclrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone/rrbvec.csv}\upclrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone/std-vec.csv}\upclstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update sequentially},
                yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}},
                legend columns=4,
                legend style={
                    at={(1.06,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\uprbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\uprrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\uppvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\uppvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\uppvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{} \balanced{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update sequentially and cloning},
                yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
                xticklabels={0, 100, \kilo{1}, \kilo{10}},
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upclstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\upclrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\upclrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\upclpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\upclpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\upclpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upclimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upclimrsvectorrelaxed};
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of updating values sequentially.}
    \label{fig:update-sequentially}
\end{figure}

\stdvec{} is the fastest vector in the sequential updates test, with the closest runner-up being \pvec{} with the mean difference of 2.32. When cloned, however, tree-based types, such as \rbvec{}, start outperforming the standard vector after surpassing the \kilo{4} size. The difference grows quickly, reaching 7.45 at the size of \kilo{20}. It demonstrates how well path copying scales when cloning large data structures.

Updates are slower for \imrsvec{} compared to \rrbvec{} by 2.47 on average. When cloned, however, the difference is less significant, varying mostly in the range of \range{[20, 400]}.

\paragraph{Balanced vs. relaxed}
Relaxed nodes and size tables associated with them were expected to have a negative impact on the performance when copying. Though, the numbers in the clone test do not confirm that assumption. However, if updated without cloning, \rrbvec{} is slower than \rbvec{} by 1.33.

\paragraph{Dynamic representation}
When updating a vector, \pvec{} is faster than both variants of \rbvec{} by a factor of 2.22 on average. It is, however, slower than \stdvec{}, even though the standard vector is used as a representation. It is expected that \pvec{} will introduce some overhead, as essentially, it introduces an additional abstraction layer.

\subsubsection*{Update randomly}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/update_randomly/im-rs-vector-balanced.csv}\upimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update_randomly/im-rs-vector-relaxed.csv}\upimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_randomly/pvec-std.csv}\uppvecstd;
        \pgfplotstableread[col sep=comma]{data/update_randomly/pvec-rrbvec-balanced.csv}\uppvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_randomly/pvec-rrbvec-relaxed.csv}\uppvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_randomly/rbvec.csv}\uprbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_randomly/rrbvec.csv}\uprrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_randomly/std-vec.csv}\upstdvector;

        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/im-rs-vector-balanced.csv}\upclimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/im-rs-vector-relaxed.csv}\upclimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/pvec-std.csv}\upclpvecstd;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/pvec-rrbvec-balanced.csv}\upclpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/pvec-rrbvec-relaxed.csv}\upclpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/rbvec.csv}\upclrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/rrbvec.csv}\upclrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/update_clone_randomly/std-vec.csv}\upclstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update randomly},
                legend columns=4,
                legend style={
                    at={(1.06,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\uprbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\uprrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\uppvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\uppvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\uppvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{} \balanced{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Update randomly and cloning},
                yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
                xticklabels={0, 100, \kilo{1}, \kilo{10}},
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\upclstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\upclrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\upclrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\upclpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\upclpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\upclpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\upclimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\upclimrsvectorrelaxed};
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of updating values randomly.}
    \label{fig:update-randomly}
\end{figure}

As with indexing, when values are updated randomly rather than sequentially, the performance gap between the \stdvec{} and \pvec{} became as small as 1.11 due to the frequent cache invalidations caused by random access. Other than that, there are no significant distinctions.

\subsection{Pushing}
Benchmarks are divided into two use cases:
\begin{itemize}
    \item Building a new vector from scratch by pushing values into it.
    \item Pushing values into an existing vector, both balanced and relaxed.
\end{itemize}

Both benchmarks are extended using the clone operation.

\subsubsection*{Building a new vector}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/push/im-rs-vector-balanced.csv}\pushimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push/pvec-std.csv}\pushpvecstd;
        \pgfplotstableread[col sep=comma]{data/push/rbvec.csv}\pushrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push/std-vec.csv}\pushstdvector;

        \pgfplotstableread[col sep=comma]{data/push_clone/im-rs-vector-balanced.csv}\pushclnimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone/pvec-rrbvec-balanced.csv}\pushclnpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone/rbvec.csv}\pushclnrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone/std-vec.csv}\pushclnstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \mega{1}},
            yticklabels={0, \micros{0.01}, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Building a new vector},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushrbvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\pushpvecstd};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushimrsvectorbalanced};
            \legend{\stdvec{}, \rbvec{}, \pvec{} \standard{}, \imrsvec{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Building a new vector and cloning it.},
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}},
                yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushclnstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushclnrbvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\pushclnpvecbalanced};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushclnimrsvectorbalanced};
            \legend{\stdvec{}, \rbvec{}, \pvec{}, \imrsvec{}}
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of push.}
    \label{fig:push}
\end{figure}

When building a vector in the \range{[20, 100]} range, tree-based types are slightly faster than \stdvec{}, as they take advantage of the tail optimization.

\imrsvec{} is almost as fast as \rbvec{} with a difference of 1.18. When cloned, however, \rbvec{} outperforms it by a significant amount of 3.61.

In the cloning benchmark, persistent vectors once more demonstrate how effective they are when copied, by \rbvec{} being faster than \stdvec{} by a staggering factor of 12.85.

\paragraph{Dynamic representation}
Overall, \pvec{} is the fastest vector, mostly due to the combination of using \stdvec{} with the pre-allocated space\footnote{\pvec{} is initialized to the capacity of branching factor, that is 32 in the test configuration.} for small sizes. Closer to the end of the size range, \stdvec{} and \pvec{} align in performance with the average difference of 1.27.

When cloned, \pvec{} is losing only to \rbvec{} by in-significant 1.35, demonstrating the effectiveness of the dynamic representation.

\subsubsection*{Adding values to an existing vector}
\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/push_relaxed/im-rs-vector-balanced.csv}\pushimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/im-rs-vector-relaxed.csv}\pushimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/pvec-std.csv}\pushpvecstd;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/pvec-rrbvec-balanced.csv}\pushpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/pvec-rrbvec-relaxed.csv}\pushpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/rbvec.csv}\pushrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/rrbvec.csv}\pushrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_relaxed/std-vec.csv}\pushstdvector;

        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/im-rs-vector-balanced.csv}\pushclnimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/im-rs-vector-relaxed.csv}\pushclnimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/pvec-rrbvec-balanced.csv}\pushclnpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/pvec-rrbvec-relaxed.csv}\pushclnpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/rbvec.csv}\pushclnrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/rrbvec.csv}\pushclnrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/push_clone_relaxed/std-vec.csv}\pushclnstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{100}},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Adding values to an existing vector},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\pushrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\pushpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\pushpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\pushpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\pushimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{20}},
                yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100},
                title={Adding values to an existing vector and cloning it},
                legend columns=4,
                legend style={
                    at={(0.5,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\pushclnstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\pushclnrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\pushclnrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\pushclnpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\pushclnpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\pushclnimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\pushclnimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of adding values to an existing vector.}
    \label{fig:push-existing}
\end{figure}

Even though size tables increase the size of the node and add complexity to the implementation, both relaxed and balanced trees show nearly identical performance in this test.

When push is called continuously, even for relaxed nodes, only balanced nodes are added to the tree. Eventually, all new nodes at the end of the tree, except the root, will be balanced. Thus, there is nearly no overhead of running push over a relaxed \rrbvec{} in the given benchmarks.

\subsection{Popping}

\begin{figure}[!htbp]

    \center
    \begin{adjustbox}{width=\textwidth}
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\scriptsize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \pgfplotstableread[col sep=comma]{data/pop/im-rs-vector-balanced.csv}\popimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/pop/im-rs-vector-relaxed.csv}\popimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop/pvec-std.csv}\poppvecstd;
        \pgfplotstableread[col sep=comma]{data/pop/pvec-rrbvec-balanced.csv}\poppvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop/pvec-rrbvec-relaxed.csv}\poppvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop/rbvec.csv}\poprbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop/rrbvec.csv}\poprrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop/std-vec.csv}\popstdvector;

        \pgfplotstableread[col sep=comma]{data/pop_clone/im-rs-vector-balanced.csv}\popclnimrsvectorbalanced;
        \pgfplotstableread[col sep=comma]{data/pop_clone/im-rs-vector-relaxed.csv}\popclnimrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop_clone/pvec-std.csv}\popclnpvecstd;
        \pgfplotstableread[col sep=comma]{data/pop_clone/pvec-rrbvec-balanced.csv}\popclnpvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop_clone/pvec-rrbvec-relaxed.csv}\popclnpvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop_clone/rbvec.csv}\popclnrbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/pop_clone/rrbvec.csv}\popclnrrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/pop_clone/std-vec.csv}\popclnstdvector;

        \begin{groupplot}[
            group style={group size=2 by 1, horizontal sep=56pt,},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 20, 100, \kilo{1}, \kilo{10}, \kilo{60}},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
        ]
            \nextgroupplot[
                xmode=log,
                ymode=log,
                title={Popping values from a vector},
                legend columns=4,
                legend style={
                    at={(1.12,-0.2)},
                    anchor=north
                }
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\popstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\poprbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\poprrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\poppvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\poppvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\poppvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\popimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\popimrsvectorrelaxed};
            \legend{\stdvec{}, \rbvec{}, \rrbvec{} \relaxed{}, \pvec{} \standard{}, \pvec{}, \pvec{} \relaxed{}, \imrsvec{}, \imrsvec{} \relaxed{}}

            \nextgroupplot[
                xmode=log,
                ymode=log,
                xticklabels={0, 20, 100, \kilo{1}, \kilo{10}},
                yticklabels={0, \micros{1}, 0.01, 0.1, 1, 10, 100},
                title={Popping values from a vector and cloning it},
            ]
            \addplot[ultra thin, color=morange, mark=*, mark size=1.2pt,] table {\popclnstdvector};
            \addplot[ultra thin, color=mred, mark=*, mark size=1.2pt,] table {\popclnrbvecbalanced};
            \addplot[ultra thin, color=mred, mark=pentagon, mark size=1.6pt,] table {\popclnrrbvecrelaxed};
            \addplot[ultra thin, color=mgreen, mark=*, mark size=1.2pt,] table {\popclnpvecstd};
            \addplot[ultra thin, color=mgreen, mark=square, mark size=1.6pt,] table {\popclnpvecbalanced};
            \addplot[ultra thin, color=mgreen, mark=diamond*, mark size=1.2pt,] table {\popclnpvecrelaxed};
            \addplot[ultra thin, color=mpurple, mark=pentagon*, mark size=1.2pt,] table {\popclnimrsvectorbalanced};
            \addplot[ultra thin, color=mpurple, mark=square, mark size=1.6pt,] table {\popclnimrsvectorrelaxed};
        \end{groupplot}
    \end{tikzpicture}
    \end{adjustbox}

    \caption{Benchmarking results of popping values.}
    \label{fig:pop}
\end{figure}

In the test without clone, \imrsvec{} is slightly faster than \rbvec{} and \rrbvec{} by 1.29. The difference between balanced and relaxed trees is only 1.02, showing that the cost of managing the relaxed tree capacity is not expensive.

\pvec{} is the second fastest vector with \stdvec{} being 1.99 faster on average. When cloned, \pvec{} switches the representation and becomes as fast as \rbvec{}.

On the other hand, \imrsvec{} is the slowest tree-based vector when cloned, but still faster than \stdvec{}, especially for large sizes.

\subsection{Appending}

\begin{figure}[t]

    \center
    \begin{tikzpicture}
        \pgfplotstableread[col sep=comma]{data/append/im-rs-vector-relaxed.csv}\imrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/append/pvec-std.csv}\pvecstd;
        \pgfplotstableread[col sep=comma]{data/append/pvec-rrbvec-relaxed.csv}\pvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/append/rbvec.csv}\rbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/append/rrbvec.csv}\rrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/append/std-vec.csv}\stdvector;

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title={Appending vectors},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \mega{1}},
            yticklabels={0, \micros{1}, 0.01, 0.1, 1, 10},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
            legend pos=north west,
            legend style={draw=none,fill=none,font=\footnotesize},
            legend cell align=left,
        ]
            \addplot[thin, color=morange, mark=*,] table {\stdvector};
            \addlegendentry{\stdvec{}}

            \addplot[thin, color=mred, mark=*,] table {\rbvecbalanced};
            \addlegendentry{\rbvec{}}

            \addplot[thin, color=mred, mark=pentagon,] table {\rrbvecrelaxed};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot[thin, color=mgreen, mark=*,] table {\pvecstd};
            \addlegendentry{\pvec{} \standard{}}

            \addplot[thin, color=mgreen, mark=diamond*,] table {\pvecrelaxed};
            \addlegendentry{\pvec{} \relaxed{}}

            \addplot[thin, color=mpurple, mark=square,] table {\imrsvectorrelaxed};
            \addlegendentry{\imrsvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \caption{Benchmarking results of appending vectors.}
    \label{fig:append}
\end{figure}

Based on the results, the naive copying of \stdvec{} is the fastest concatenation algorithm up to the problem size of \kilo{40}. However, after surpassing \kilo{40} it quickly degenerates and loses to \rrbvec{} by 6.53, with a maximum difference of 12.85 for the size of \mega{1}.

Even though not for all input sizes, we can see that \rrbvec{}'s concatenation algorithm scales better and eventually outperforms \stdvec{}.

\imrsvec{} catches up to \stdvec{} only at the size of \kilo{400}, still being slower than \rrbvec{} by 1.29 at that point.

\paragraph{Balanced vs. relaxed}
For the input size up to \kilo{2}, \rbvec{} and \rrbvec{} show similar results. The simplicity of naive concatenation used by \rbvec{} is sufficient to be as fast as \rrbvec{} due to the small problem size.

This, however, drastically changes after the \kilo{2} size, where \rbvec{} continuously degrades, showing the worst results among all vectors. The performance difference between \rbvec{} and \rrbvec{} at the size of \mega{1} is staggering 145.59.

As for \pvec{}, it follows the curves of \stdvec{} and \rrbvec{} because of the dynamic representation, as expected.

\subsection{Splitting}

\begin{figure}[t]

    \center
    \begin{tikzpicture}
        \pgfplotstableread[col sep=comma]{data/split_off/im-rs-vector-relaxed.csv}\imrsvectorrelaxed;
        \pgfplotstableread[col sep=comma]{data/split_off/pvec-std.csv}\pvecstd;
        \pgfplotstableread[col sep=comma]{data/split_off/pvec-rrbvec-relaxed.csv}\pvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/split_off/rbvec.csv}\rbvecbalanced;
        \pgfplotstableread[col sep=comma]{data/split_off/rrbvec.csv}\rrbvecrelaxed;
        \pgfplotstableread[col sep=comma]{data/split_off/std-vec.csv}\stdvector;

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title={Splitting vectors},
            xlabel={Vector size (log scale)},
            ylabel={Mean time (log scale) [\millis{}]},
            xticklabels={0, 100, \kilo{1}, \kilo{10}, \kilo{100}, \kilo{400}},
            yticklabels={0, \micros{0.1}, \micros{1}, 0.01, 0.1, 1, 10, 100, \seconds{1}, \seconds{10}},
            ymajorgrids=true,
            xmajorgrids=true,
            grid style=dashed,
            legend pos=north west,
            legend style={draw=none,fill=none,font=\footnotesize},
            legend cell align=left,
        ]
            \addplot[thin, color=morange, mark=*,] table {\stdvector};
            \addlegendentry{\stdvec{}}

            \addplot[thin, color=mred, mark=*,] table {\rbvecbalanced};
            \addlegendentry{\rbvec{}}

            \addplot[thin, color=mred, mark=pentagon,] table {\rrbvecrelaxed};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot[thin, color=mgreen, mark=*,] table {\pvecstd};
            \addlegendentry{\pvec{} \standard{}}

            \addplot[thin, color=mgreen, mark=diamond*,] table {\pvecrelaxed};
            \addlegendentry{\pvec{} \relaxed{}}

            \addplot[thin, color=mpurple, mark=square,] table {\imrsvectorrelaxed};
            \addlegendentry{\imrsvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \caption{Benchmarking results of splitting vectors.}
    \label{fig:split}
\end{figure}

% TODO: you have to be open about:
%  1: split_off and append are fast*er* compared to vec only for large sizes
%   1.1: this is part of the reason why in par benchmarks tree-based vectors suck
%  2: split_off benchmark is biased as it favors the use-case that is faster for the tree-based implementations

The performance advantage of \stdvec{} over \rrbvec{} is 3.24 up to the size of \kilo{20}, after which it degrades and gets slower than \imrsvec{} and \rrbvec{} by 5.95. The difference is more significant for \rbvec{} at the factor of 65.65 for the size of \kilo{400}.

\subsection{Rc vs Arc}
\label{sec:perf-rc-vs-arc}
\todo{Execute sequential benchmarks using \arc{} pointer}
\stdvec{} is not included in the comparison, as its implementation does not rely on the reference counted pointers.

\section{Parallel benchmark results}
\label{sec:perf-par}

The expectation from parallel benchmarks is to reveal whether proposed optimizations were effective in the parallel context.

First, if confluent concatenation and slice operations of \rrbvec{} are faster compared to \rbvec{}. And second, whether the dynamic representation has a positive impact on the overall performance of \pvec{}.

At last, we will evaluate the impact of the increasing number of threads on the performance.

The results are presented in the form of a three-dimensional graph, where x and y-axis correspond to the problem size and number of threads used, while z is used for the mean run time.

\subsection{Adding elements of two vectors.}

\begin{figure}[!htbp]

    \center
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\footnotesize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title style={align=center},
            title={Adding elements of two \n{} sized vectors\\ parallelised on \emph{K} number of threads.},
            ymajorgrids=true,
            xmajorgrids=true,
            zmajorgrids=true,
            xlabel={Vector size (log scale)},
            ylabel={Number of threads (log scale)},
            zlabel={Mean time (log scale) [\millis{}]},
            xticklabels={10, 100, \kilo{1}, \kilo{10}},
            ytick={1, 2, 4, 8},
            yticklabels={1, 2, 4, 8},
            zticklabel style={
                /pgf/number format/fixed,
                /pgf/number format/precision=2
            },
            zticklabel={%
                \pgfmathfloatparsenumber{\tick}%
                \pgfmathfloatexp{\pgfmathresult}%
                \pgfmathprintnumber{\pgfmathresult}%
            },
            grid style=dashed,
            legend pos=outer north east,
            legend style={fill=none,font=\footnotesize},
            legend cell align=left,
            view={-45}{8},
        ]
            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mred] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/std-vec.csv};
            \addlegendentry{\stdvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=morange] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/rbvec-balanced.csv};
            \addlegendentry{\rbvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=blue] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/rrbvec-relaxed.csv};
            \addlegendentry{\rrbvec{} \relaxed{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mgreen] table [x={size}, y={threads}, z={time}, col sep=comma] {data/vector_addition/pvec-relaxed.csv};
            \addlegendentry{\pvec{} \relaxed{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \label{fig:adding-two-vectors-par}
    \caption{Adding elements of two \n{} sized vectors parallelised on \emph{K} number of threads.}
\end{figure}

% NOTE: you can justify this by the goal of minimizing the overhead of the actual computation, to have a simpler way to compare different vector implementations.

\paragraph{Balanced vs relaxed}
\rbvec{} and \rrbvec{} show nearly identical results in sequential benchmarks. This is expected, as concatenation and slice operations that create relaxed nodes were not used. Hence, \rrbvec{} remains balanced throughout the test, and is backed by the same representation of \rrbtree{} as \rbvec{}. Both variants are consistently slower compared to \stdvec{} with a difference of 3.2-3.5x on average.

When executed in parallel, \rrbvec{} starts outperforming \rbvec{} at the size of 1024 elements. The reason why difference becomes apparent after surpassing that size is that the concatenation algorithm used in this project produces balanced \rbtree{} when the height of the tree does not exceed two levels. With the branching factor of 32, the capacity of the tree of two levels is equal to 1024.

As the vector size grows, Rayon performs more slices to achieve optimal vector size per a single thread. This, in a turn, results in a higher number of concatenations necessary to combine execution results. Since \rbvec{} has the naive implementation of concatenation and slice, its performance degrades with the input size growth. The difference in execution time depending on size falls into the 1.0-2.3x range.

To keep available threads busy, Rayon divides the available pool of work into smaller pieces. Hence, the growing number of threads increases the performance gap between \rbvec{} and \rrbvec{} even further, as slice and concatenation is used more frequently. In the test with 2, 4 and 8 threads, \rbvec{} is slower than \rrbvec{} by a factor of 1.0-2.3x, 1.0-2.8x, and 1.1-2.12x correspondingly.

\paragraph{Dynamic representation}
\pvec{} consistently demonstrates better results compared to \rrbvec{}. This can be explained by the fact that it uses \stdvec{} as its internal representation until the concatenation stage, during which it upgrades to \rrbvec{}. In the sequential benchmark, \pvec{} is faster compared to \rrbvec{} by 1.7-2.0x. When parallelized on 4 threads, \rrbvec{} becomes slightly more efficient due to the higher count of concatenations and slices, with the difference at 1.3-1.8x.

Even though \rrbvec{}'s concatenation and slice operations are faster for the large-sized vectors, \stdvec{} showed the best results in all tests. It is important to keep in mind that concatenations and slices substitute only a small portion of all operations used in this test. Operations such as get and push, which were extensively used in this benchmark, are still faster for \stdvec{}. Thus, the closest runner up -- \pvec{}, is slower by 1.8-1.9x and 1.6-1.7x in the sequential and 4-threaded parallel benchmarks correspondingly.

\paragraph{Effect of parallelism}
% TODO: this is not entirely true, because 4 threads benchmark runs slightly faster for large datasets compared to sequential bench.
The sequential variant of the benchmark outperformed all subsequent parallel tests. This can be explained by the overhead induced by the distribution of work between multiple threads, which outweighs the benefits of solving a relatively simple problem in parallel.

\subsection{Check if a word is a palindrome}

\begin{figure}[!htbp]

    \center
    \begin{tikzpicture}
        \tikzstyle{every node}=[
            font=\footnotesize,
            inner sep=2pt,
            outer sep=0pt
        ]

        \begin{loglogaxis}[
            smooth,
            width=300pt,
            title style={align=center},
            title={Filtering palindromes on \emph{K} number of threads.},
            ymajorgrids=true,
            xmajorgrids=true,
            zmajorgrids=true,
            xlabel={Vector size (log scale)},
            ylabel={Number of threads (log scale)},
            zlabel={Mean time (log scale) [\millis{}]},
            xticklabels={10, 100, \kilo{1}, \kilo{10}, \kilo{100}, \kilo{400}},
            ytick={1, 2, 4, 8},
            yticklabels={1, 2, 4, 8},
            zticklabel style={
                /pgf/number format/fixed,
                /pgf/number format/precision=2
            },
            zticklabel={%
                \pgfmathfloatparsenumber{\tick}%
                \pgfmathfloatexp{\pgfmathresult}%
                \pgfmathprintnumber{\pgfmathresult}%
            },
            grid style=dashed,
            legend pos=outer north east,
            legend style={fill=none,font=\footnotesize},
            legend cell align=left,
            view={-45}{8},
        ]
            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mred] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/std-vec.csv};
            \addlegendentry{\stdvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=morange] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/rbvec-balanced.csv};
            \addlegendentry{\rbvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=blue] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/rrbvec-relaxed.csv};
            \addlegendentry{\rrbvec{}}

            \addplot3[surf, mesh/rows=4, opacity=0.1, fill opacity=0.3, color=mgreen] table [x={size}, y={threads}, z={time}, col sep=comma] {data/words_filter/pvec-relaxed.csv};
            \addlegendentry{\pvec{}}
        \end{loglogaxis}
    \end{tikzpicture}

    \label{fig:words-filter}
    \caption{Filtering palindromes on \emph{K} number of threads.}
\end{figure}

\paragraph{Balanced vs relaxed}
As expected, \rbvec{} and \rrbvec{} are equally fast in the sequential test as both of them are backed by a balanced \rbtree{}. When the benchmark is parallelized, \rrbvec{} gains advantage due to its efficient slice and concatenation operations. The difference between variants grows along with the increasing count of threads. Specifically, it is 1.5-2.0x for the test run with 2 threads, and 1.7-2.5x for 4 threads.

\paragraph{Dynamic representation}
Results show that \pvec{} outperforms \rbvec{} and \rrbvec{} for all vector sizes and thread configurations. When it comes to \stdvec{}, \pvec{} shows 1.4x slower run time at the input size of 10000 words, after which it catches up and surpasses \stdvec{} at the mark of 200000 words. For the biggest problem size of 370103 words, \pvec{} outperforms \stdvec{} with a difference of 1.1x.

The increase in the thread count causes a higher count of vector slices and concatenations. Thus, the bigger the problem size and the thread count is, the more advantages \pvec{} provides, demonstrating performance results comparable to \stdvec{}.

% \section{Discussion}
% The performance of the \rrbvec{} implementation and the different optimizations were evaluated through repeated runs of the benchmarks, and is compared to other implementations such \stdvec{} and \imrsvec{}.
