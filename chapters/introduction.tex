% The experience of dealing with these errors often can be frustrating, especially for programmers new to Rust.

% However, the Rust developers have spent a large amount of time working to improve the error messages to ensure that they are clear and actionable. Don’t let your eyes gloss over while reading Rust errors!

\chapter{Introduction}
\todo{The parallel vector extensions in a better way}
\todo{Interaction with community and Niko}
\todo{Check that you're consistently using straight or curly quotes}

% Total volume of the introduction should not exceed 5-6 paragraphs

% 1. Why Rust is cool and worth your time. Why: a, b, c
Rust is a modern, open-source programming language with a focus on memory safety and performance. Its rich type system not only eliminates several classes of bugs but also makes the language powerful and expressive for building high-level programs such as web servers and command-line interface applications. With direct access to computer memory and hardware, Rust is a great language for embedded and low-level programming as well.

% 2. What are the challenges of working with Rust? a, b, c
However, due to the emphasis on memory safety and rigorous checks enforced by the compiler, it is common to get errors when compiling a Rust program. One of the rules is the forbidden simultaneous sharing and mutation of an object. Often, errors caused by this rule can be avoided by better design, but sometimes, the best resolution is to clone the value before sharing it. Naive cloning by copying, however, is an expensive operation both in terms of time and space. Thus, resorting to it as a solution, especially for large-sized collections might be in-efficient.

% 3. Persistent data structures can help: why, and how? a, b, c
Persistent data structures are the data structures that provide access to all their previous versions. Often persistence is achieved through copying, and thus, various data structure designs have been developed throughout the years to optimize for this operation. The standard library of the Scala programming language\footnote{\url{https://www.scala-lang.org/}} provides a persistent vector implementation that is efficient not only when copied but also across all operations.

% 4. Okay, now we understand what are the challenges, and why Rust and persistent
%      data structures are a match made in heaven. What is my role in this story?
This thesis presents \pvecrs{}, a project that contributes a vector implementation with efficient clone operation that borrows ideas from persistent data structures. The project explores novel approaches to optimize vector’s performance by leveraging type system of Rust, as well as aiming to achieve convenient, idiomatic interface familiar to developers. The proposed optimizations are evaluated and discussed based on results of the sequential and parallel tests.

% 5. Let's learn a little bit more about Rust and Persistent data structures first
In this introductory chapter, we will look at the background for the \pvecrs{} project. First, in section \ref{sec:rust}, we will look at the Rust programming language. Then, in section \ref{sec:psds}, we will take a closer look at persistent data structures and their categories. Finally, section \ref{sec:contributions} gives an overview of the contributions made in this project.

In chapter 2, the data structure that serves as the foundation for the persistent vector in Rust -- the RRB-Tree, is presented. In chapter 3, the \pvecrs{} project, its interface, and optimizations specific to Rust are discussed in detail. Chapter 3 focuses on the performance evaluation of the data structures and discusses ways in which it could be extended and improved.

% Stack, Heap, and garbage collection

\section{The Rust programming language}
\label{sec:rust}

% 1. Rust is a new programming language developed at Mozilla that offers high level constructs such as a, b, and c
Rust is a relatively new programming language developed at Mozilla that favors reliability and performance. It is a statically type language with type inference, with high-level constructs such as closures, pattern matching and algebraic data types. At the same time, Rust gives the option to control low-level details, such as memory management, without all the unsafety traditionally associated with it.

% 2. At the same time, it offers low-level control to do: a, b, c; that makes it a viable alternative to C/C++
Rust does not have a garbage collector and can be configured without standard library, allowing it to be used for programming microcontrollers, operating systems and drivers, the domain that has been occupied mainly by C/C++. It avoids the tradeoff between control and safety by statically checking memory correctness at compile-time without introducing any runtime overhead \cite{reed-patina}.

% 5. It guarantees memory safety through its type system, and here is how.
The advanced type system of Rust guarantees memory safety by enforcing ownership and borrowing rules, making Rust a unique programming language that helps to write fast, safe and reliable software.

% 6. This project is written in Rust. The following sections will introduce relevant parts of the language. For more details read the book.
The project presented in the thesis, \pvecrs{}, contributes the persistent vector to the Rust programming language. The following sections are a very basic introduction to the relevant parts of Rust touched in this thesis. For a more in-depth overview of the more advanced language features, see the Rust book\footnote{\url{https://doc.rust-lang.org/book/}}.

\subsection{Ownership and borrowing}

\paragraph{Ownership}
Ownership is Rust's most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Every object allocated in Rust always has an \emph{owner}. Ownership can be transferred from one function to another by \emph{moving} the object. Rust's compiler is capable of tracking these movements and identify the location where the object is no longer used, or in Rust's terminology, where it goes out of scope, and generate code for destroying that object. To summarize:

\begin{itemize}
    \item Each value in Rust has a variable that is called its owner.
    \item There can only be one owner at a time.
    \item When the owner goes out of scope, the value will be dropped.
\end{itemize}

\paragraph{Borrowing}
Borrowing in Rust is the act of creating references to an object. The compiler checks that references always go out of scope before the object they are pointing to, returning an error if it does not, thus guaranteeing that references will never be dangling pointers \cite{reed-patina}. The borrowing rules are:

\begin{itemize}
    \item At any given time, you can have either one mutable reference or any number of immutable references.
    \item References must always be valid: they cannot outlive an object they are pointing to, and they have to point to an object of a correct type.
\end{itemize}

Ownership and borrowing rules are demonstrated in listing \ref{lst:ownership-and-borrowing} that was taken from \cite{linus-parallelization}. On line 2, a new vector is created and assigned to the \mintinline{rust}{vec} variable. Since \mintinline{rust}{vec} owns the object, it is allowed to mutate it by pushing a value on line 3.

\begin{listing}[!htbp]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{rust}
        fn main() {
            let mut vec = Vec::new();
            vec.push(42);

            { // Two references are created.
                let vecref = &vec;
                borrow(&vec);
                // ^ Ref goes out of scope when borrow returns
            } // vecref goes out of scope here

            borrow_mut(&mut vec); // <- Lend ‘vec‘ mutably to ‘borrow_mut‘
            take(vec); // <- Ownership transferred to ‘take‘
            vec.push(37); // <- Error: use of moved value: ‘vec‘
        }

        fn take(mut my_data: Vec<i32>) {
            my_data.push(99); // ‘my_data‘ is owner, can perform mutation
        } // ‘my_data‘ goes out of scope and will be freed here

        fn borrow(vec: &Vec<i32>) {
            vec.push(10); // error: cannot borrow immutable borrowed ...
            let element = vec.get(0); // Read is possible.
        } // Borrowing ends, but ‘vec‘ continues to live in ‘foo‘

        fn borrow_mut(vec: &mut Vec<i32>) {
            vec.push(0); // Mutable borrow of ‘vec‘, can mutate.
        }
    \end{minted}

    \caption{Demonstrating ownership and borrowing rules.}
    \label{lst:ownership-and-borrowing}
\end{listing}

On lines 6 and 7, two references are created with the \mintinline{rust}{&} operator. One of them is borrowed by the \mintinline{rust}{borrow} function, with the \mintinline{rust}{vec} still being the owner. When \mintinline{rust}{borrow} returns, the reference goes out of the scope first, and then the same happens to \mintinline{rust}{vecref} a line later. The two references are a demonstration of the possibility to simultaneously create more than one immutable reference to the same object.

On line 10 a new mutable reference is created with the \mintinline{rust}{&mut} operator. While data is borrowed mutably no other references can exist. When \mintinline{rust}{borrow_mut} returns the reference goes of the scope.

When the function \mintinline{rust}{take} is invoked the ownership to the \mintinline{rust}{vec} object is transferred to the variable \mintinline{rust}{my_data}. The \emph{move} happens because \mintinline{rust}{take} accepts the object by value rather than by a reference. Compiler will error on attempt to use \mintinline{rust}{vec} after it has been moved on line 13.

\paragraph{Eliminating data races and use after free bugs}
% When choosing a programming language developers usually have to choose between managing the memory manually or having a built in garbage collector do it for them. Manually managing memory, like in C/C++, provides a certain amount of control. Manually managing memory gives the ability to specify exactly when to allocate and free as well as what to do with it. This freedom comes at the cost of responsibility and error prone code. On the other hand, garbage collectors mitigate the common errors, but at the cost of lost control and usually with some performance penalty. Most modern languages are more or less making a tradeoff between control and safety. [17]

% Rust solves the use after free problem by introducing the concepts of ownership and borrowing. Ownership means that there is always a clear owner of a piece of data, and when the data goes out of scope, meaning the owner is done with it, Rust automatically frees it. Rust can automatically free the data since the compiler has already checked that any references created to it has gone out of scope before the data itself. Borrowing in Rust is the act of creating a reference to a piece of data. The compiler checks that references always go out of scope before the data they are pointing to, giving an error if it does not, thus guaranteeing that references will never be dangling pointers. [18]

% Rust solves the issue of data races by only allowing mutation2 of data when no aliases for that data exist. Either the owner of the data can mutate it or someone holding the exclusive mutable reference to it. A mutable reference to data can be created when no other references exist, and during the lifetime of that reference no other references can be created to that same data. [17]

% Today it is common knowledge within the computer science community that the way to speed up computations is to make them parallel and make use of the many cores that modern processors have. However, writing parallel software is difficult, since it is complex to avoid deadlocks and race conditions, as described by Sutter [1]. Much of what makes it difficult is shared state, where multiple threads of execution access the same memory location. If a thread writes to a memory location at the same time as another thread reads or writes to it, content will not be consistent and likely produce an error. [2]

A data race is when multiple threads reference the same data, and one thread writes to that data at the same time as another thread accesses it.

Use after free bugs happen when a reference is taken to some data that no longer exists and points to an invalid memory address.

Rust eliminates both classes of bugs by failing compilation when ownership and borrowing rules are violated.

\subsection{Memory management: the stack and the heap}
In programming languages such as Java, there is no distinction between the stack and the heap memory, because language abstracts them away from a developer. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions.

The stack is very fast and is where memory is allocated in Rust by default. But the allocation is local to a function call and is limited in size. The heap, on the other hand, is slower and is explicitly allocated by your program. But it’s effectively unlimited in size and is globally accessible.

The following section gives an overview of how Rust supports heap allocation.

\subsubsection*{Smart pointers}
\emph{Smart pointers} are data structures that not only act like a pointer but also have additional metadata and capabilities.

The most straightforward smart pointer is \type{Box<T>} that allows storing data on the heap rather than the stack.

\begin{listing}[!htbp]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{rust}
        fn main() {
            let b = Box::new(5); // <- 5 will be stored on the heap.
            println!("b = {}", b);
        }
    \end{minted}

    \caption{Example of using box smart pointer.}
    \label{lst:box}
\end{listing}

When box pointer in listing \ref{lst:box} goes out of the scope on line 4, corresponding heap allocation gets freed as well.

\begin{listing}[!htbp]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{rust}
        fn main() {
            let mut rc = Rc::new(Vec::new());
            // ^ Wrapping the vec instance into rc pointer
        
            Rc::make_mut(&mut rc).push(42);
            // ^ Ref count is 1, push succeeds without cloning.
        
            take(rc.clone()); // <- Ref count is incremented to 2.
            Rc::make_mut(&mut rc).push(37); // <- Updating the original 'vec'.            
        } <- 'rc' is decremented to 0 and dropped
        
        fn take(mut my_rc: Rc<Vec<i32>>) {            
            Rc::make_mut(&mut my_rc).push(99); 
            // ^ Mutating the object with ref count of 2 
            // will clone the wrapped value and then update it.     
        } // ‘my_rc' is decremented to 0 and dropped.
    \end{minted}

    \caption{Example of using reference counting pointer.}
    \label{lst:rc}
\end{listing}

% TODO: smart pointer types

% \subsection{Safe and unsafe flavors of Rust}
% Using unsafe code is not something that should be avoided in Rust, but the amount of code that is unsafe should be kept relatively low for easier debugging. Rust forces the developers to find a safer solution to problematic code or mark it as unsafe and thus highlight the code as a potential source of problems during future debugging.

% \subsection{Send + Sync traits and threads}
% ## Modern challenges with parallelism

\subsection{Enums, structs and traits}

\section{Persistent data structures}
\label{sec:psds}

A vast majority of modern programming languages are equipped with a standard library --- a set of constructs and utilities aimed to improve the developer's productivity.

A significant part of standard library consists of commonly used data structures such as lists, sets, and maps, which often provide operations for reading and writing data.

Modifying or \emph{mutating} an \emph{ephemeral} data structure implies that we no longer will have access to its older version. In contrast, a \emph{persistent} data structure allows access to any version, old or new, at any time \cite{making-data-structures-persistent}.

Persistent data structures could be classified based on the operations which they offer over their versions:
\begin{itemize}
    \item \textit{Partial persistence} --- In this persistence model, we can query any previous version of the data structure, but we can update only the newest version. The versions are linearly ordered.
    \item \textit{Full persistence} --- Both access and updates are allowed on all versions. The versions can be visualized as a branching tree.
    \item \textit{Confluent persistence} --- In addition to the previous operations, it offers combination operation to merge more than one previous version to output a new single version. The versions form a directed acyclic graph \cite{fully-persistent-lists-with-catenation}.
    \item \textit{Functional persistence} --- This model takes its name from functional programming where objects are immutable. In comparison to the previous models, it prohibits change of the internal representation of the data structure \cite{purely-functional-data-structures}.
\end{itemize}

While persistence can be achieved by simple copying, the performance of a modification operation quickly becomes unacceptable. This led to research and development of more efficient solutions, which were often designed to solve particular problems. A lack of general purpose collections, which guarantee uniformly good performance across different operations, results in challenges with software development.

A persistent \emph{vector}, also known as a one-dimensional growable array, is very inefficient if implemented naively. Each update operation will cause a full copy of the underlying array, consuming additional amount of memory and processor time.

However most operations modify only some parts of data structures, a complete copy is redundant. A better approach is to exploit the similarity between the new and old versions by \emph{sharing} structure between them. For example, instead of representing a data structure as a single block of memory, it could be broken down into smaller pieces or \emph{nodes}, which are linked together in the form of a \emph{tree}. Since modifications only apply to some nodes, the rest of them still remain unchanged and can be shared without copying.

The first persistent vector implementation which offered good performance across a broad range of operations was introduced by Rich Hickey in the Clojure programming language. It was based on Phil Bagwell's Hash Array Mapped Trie \cite{ideal-hash-trees}, which offers practically constant runtime for push, update, and access operations, and it is a \emph{fully} persistent data structure.

Later Phill Bagwell introduced a confluently persistent vector based on Relaxed Radix Balanced Tree \cite{efficient-immutable-vectors}, which has improved performance of the concatenation operation significantly and became a foundation for Scala's standard library vector implementation.

The project presented in the thesis contributes an efficient persistent vector implementation for Rust based on Relaxed Radix Balanced Tree, which takes advantage of the Rust's type system to improve performance, guarantee thread safety and provide an idiomatic application programming interface. In order to ensure the best possible average performance, its internal representation switches from standard vector to RRB-Tree during runtime.

\section{Contributions}
\label{sec:contributions}
\todo{Contributions}
