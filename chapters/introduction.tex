\chapter{Introduction}

\section{Persistent data structures}

A vast majority of the modern programming languages are equipped with a standard library --- a set of constructs and utilities aimed to improve the developer productivity. 

A significant part of the standard library consists of commonly used data structures such as lists, sets, and maps, which expose operations for reading and writing data. 

Modifying or \emph{mutating} an \emph{ephemeral} data structure implies that we no longer will have access to its older version. In contrast, a \emph{persistent} data structure allows access to any version, old or new, at any time \cite{making-data-structures-persistent}. 

Different types of persistence could be described based on the operations which they offer over their versions:
\begin{itemize}
    \item \textit{Partial persistence} --- In this persistence model, we can query any previous version of the data structure, but we can update only the newest version. The versions are linearly ordered. 
    \item \textit{Full persistence} --- Both access and updates are allowed on all versions. The versions can be visualized as a branching tree.
    \item \textit{Confluent persistence} --- In addition to the previous operations, it offers combination operation to merge more than one previous versions to output a new single version. The versions form a directed acyclic graph \cite{fully-persistent-lists-with-catenation}.  
    \item \textit{Functional persistence} --- This model takes its name from functional programming where objects are immutable. In comparison to the previous models, it prohibits change of the internal representation of the data structure \cite{purely-functional-data-structures}. 
\end{itemize}

Since functional programming languages prohibit mutability by design, data structures defined in them are inherently persistent. While persistence can be achieved by simple copying, the performance of a modification operation quickly becomes unacceptable. 

Most persistent data structures are optimized to some specific operations, which are executed very fast, at the expense of the others. Thus, they are often limiting for the general purpose use. 

A persistent \emph{vector} --- one-dimensional growable array, is very inefficient if implemented naively. Each update operation will cause a full copy of the underlying array, consuming additional amount of memory and processor time. 

Since most operations modify only some parts of data structures, the complete copying is redundant. A better approach is to exploit the similarity between the new and old versions to \emph{share} structure between them. 

For example, when a new node is added to a tree, the only modified part will be the path containing the new node. The rest of the structure will remain untouched and could be shared. 

The first persistent vector implementation which offered good performance across broad range of operations was introduced by Rich Hickey in the Clojure programming language. It was based on Phil Bagwell's Hash Array Mapped Trie \cite{ideal-hash-trees}, which offers practically constant runtime for push, update, and access operations, and it is a \emph{fully} persistent data structure. 

Later Phill Bagwell has introduced a confluently persistent vector based on Relaxed Radix Balanced Tree \cite{efficient-immutable-vectors}, which has improved performance of the concatenation operation significantly and became a foundation for the Scala's standard library vector implementation. 

The project presented in the thesis contributes an efficient persistent vector implementation for Rust based on Relaxed Radix Balanced Tree, which takes advantage of the Rust's type system to improve performance, guarantee thread safety and provide an idiomatic application programming interface. In order to ensure the best possible average performance, its internal representation switches from the standard vector to the RRB-Tree during runtime. 

\section{The Rust programming language}

% Notes:
% 1) Which constructs does Rust offer?
% 2) What are the different trade-offs between types?
% 3) Why have you chosen this particular type?

Rust is a systems programming language that aims to be modern, safe and fast. It doesn't have a garbage collector and has a minimal runtime, which makes it suitable for the "low level" problems, such as development of firmware, drivers and operating systems. These properties put Rust next to the C and C++ programming languages. The advanced memory control and the linear type system are combined together to increase developer productivity without sacrificing memory safety.

Syntax of Rust is similar to the one in C, but it also brings many novel features of object oriented and functional programming languages. This section introduces the basic features of the language relevant to this paper and discusses some of the trade offs associated with them. To get familiar with specific language features consult the Rust book \cite{rust-book-2e}.

\subsection{Structs}

\begin{listing}[ht!]
\begin{minted}{Rust}
struct Book {
    author: String, 
    name: String
}

// instantiating struct
let rust_book = Book { 
    author: "Klabnik, Steve", 
    name: "The Rust Programming Language"
}
\end{minted}
\caption{A basic Rust struct}
\label{lst:struct}
\end{listing}

Structs is the most common way to declare complex custom types in Rust without introducing runtime overhead. Structs are solely used to represent the state, meaning that behavior or methods cannot be declared within the struct's body. Inheritance is prohibited by design, while polymorphism can be achieved by using other language constructs discussed later. 

\subsection{Enums}

% This section must explain the difference between closed type sets (enums) and open type sets (trait objects).
% Section with introduction to Rust must include a paragraph on safe and un-safe flavors of the language.

% Resources:
% [2] - \url{https://tonyarcieri.com/a-quick-tour-of-rusts-type-system-part-1-sum-types-a-k-a-tagged-unions}
% [3] - \url{http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/}
% [4] - \url{https://en.wikipedia.org/wiki/Tagged_union}

\begin{listing}[ht!]
\begin{minted}{Rust}
struct Point(isize, isize);

enum Shape {    
    Rectangle { 
        p_1: Point, 
        p_2: Point 
    }, 
    Triangle { 
        p_1: Point, 
        p_2: Point, 
        p_3: Point 
    }    
};

// instantiating enum
let rectangle = Shape::Rectangle {
    p_1: Point(0, 0), 
    p_2: Point(8, 16)
}
\end{minted}
\caption{A basic Rust enum}
\label{lst:enum}
\end{listing}

Enumerations or enums, are used to define a custom type by enumerating its possible values. Enum declaration includes variants, where each variant might have data associated with it. The size of an enum instance is equal to the maximum size of its variants, which means that we can pass them around by value. On the other hand, it also can be a cause of performance problems. For example, \texttt{\textbf{Shape::Rectangle}} will be allocated the same amount of memory as \texttt{\textbf{Shape::Triangle}}, even though it contains only two points. 

\subsection{Traits}

\begin{listing}[ht!]
\begin{minted}{Rust}
struct Email(String);
struct Tweet(String);

trait Message {
    fn send();
}

impl Message for Email {
    fn send() { /* sending email */ }
}

impl Message for Tweet {
    fn send() { /* sending tweet */ }
}
\end{minted}
\caption{A basic Rust trait}
\label{lst:enum}
\end{listing}

Trait describes common behavior of types implementing it. Conceptually it is similar to an interface in Java with some differences. One of the trait's super powers is ability to implement them for types you do not own. Traits support default function implementations, as well as inheritance. 

\subsection{Ownership and borrowing}
\todo{Ownership and borrowing}

\subsection{Reference counting and memory management}
\todo{Reference counting and memory management}

\section{Contributions}
\todo{Contributions}
