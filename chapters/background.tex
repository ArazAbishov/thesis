% TODO: give a definition to core (discrete operations)
%   This is how you can distinguish core from confluent operations:
%     * Core operations do not produce relaxed nodes in \rrbtree{} unless the nodes on the path to the leaves are already relaxed
%     * Alternative name for core is discrete

% TODO: define what is transience: https://clojure.org/reference/transients
\chapter{Background}

\section{Radix balanced tree}
\label{chapter:radix-balanced-tree}

Radix balanced tree or \treerb{} is an \m{}-ary tree that uses integers as keys to find values. The data structure was pioneered by Rich Hickey as the foundation for the persistent vector implementation in Clojure \cite{the-clojure-programming-language}.

\treerb{} consists of nodes which reference other subtrees or values. We will be referring to the former and latter types of nodes as \emph{branches} and \emph{leaves} correspondingly. The number of subtrees and values in the node is configurable and will be defined as \m{} or the \emph{branching factor}. The branching factor can be any number that is a power of 2, allowing an efficient radix search implementation.

The higher the value of \m{} is, the wider and shallower the tree will be. From now on the height of a tree will be referred to as \h{}, where $h_{max}$ is the upper boundary:

\begin{equation} \label{eq:h-max}
    h_{max} = log_m(n)
\end{equation}

When \m{} is a large value, for example, 32, the tree becomes shallow, and the complexity of accessing values by traversing the tree from the root to a leaf becomes \emph{effectively} constant. For example, if the maximum value of 32 bit signed integer is substituted for $n$ in \Cref{eq:h-max} then $h_{max}$ will never exceed 7 levels. Thus, due to its strong performance guarantees, \treerb{} serves as a solid foundation for a general-purpose persistent vector implementation.

In the following sections, we will take a look at \treerb{} algorithms used to implement vector operations\footnote{For a formal definition of \treerb{}, refer to \cite{improving-performance-through-transience}}.

\subsection{Radix search}
\label{sec:rb-tree-radix-search}

Before trying to understand how operations such as push, pop, and update work, let's take a look at how to access values in \rbtree{}. The lookup mechanism is called \emph{radix search}, a fundamental algorithm which forms the basis for other operations.

Conceptually, the idea behind the search in an ordered tree-like structure boils down to picking correct nodes based on the given key. If there is a value corresponding to the key, we stop searching and return the value. Otherwise, an empty value or error is returned.

The lookup mechanism depends on organization of nodes in the tree. Let's consider an example where each node has at most two children, called \emph{binary tree}. A binary tree where every node fits a specific ordering property\footnote{For every node $n$, all left descendents must be less than or equal than $n$, and all right descendents must be strictly bigger than $n$.} is called \emph{binary search tree}. While searching, the key at each node is compared to the search key. All that is important is whether the key in the node is less than, equal to, or greater than the search key. The search is continued until an exact match or reaching a leaf node.

Another tree-like data structure known as trie, is interesting because its nodes do not store complete keys. Instead, each node stores only part of it. Since tries are often used for the prefix search of words, their nodes store characters. Each path down the tree may represent a word. A node in a trie could have anywhere from 0 through the size of the alphabet children. For example, the english alphabet has 26 letters, meaning that each node might have up to 26 children.

The lookup procedure for tries involves breaking down the search key into multiple subkeys, which are used to pick corresponding sub-tries. For example, the key "car" will be broken down into several smaller keys such as "c", "a", "r". If there is a value present at the last node of the path, it is returned. Otherwise, an empty value or error is returned.

\subsubsection*{Bit partitioning}
Radix search accepts a key of integer type as an argument. It can be viewed as a composite key, where each subkey is represented by a sequence of bits. The idea is to divide the key into blocks of bits, where each block forms an index specific to the tree node. The count of bits in each of those chunks can be derived from the branching factor and will be named as \emph{bits per level}.

The \emph{bits per level} or \x{} is the count of bits used to address \m{} nodes in the binary numeral system:

\begin{equation}
    \label{eq:bits-per-level}
    x = log_2(m).
\end{equation}

For example, with \m{} equal to 16, the maximum index value is 15. 15 converted to the binary form is $1111_2$, which evidently requires 4 bits of space. If we substitute \m{} into \Cref{eq:bits-per-level}, we will get the same value.

\subsubsection*{Extracting subkeys}
Now when the size of the subkey is known, the next step is to identify its location. The count of subkeys within the search key depends on \h. Each new level in \rbtree{} will use \x{} additional bits of space. For instance, a search key addressing an element of the tree of ${h = 3}$ and ${x = 2}$ will consist of 3 subkeys taking up 6 bits of space in total.

Subkeys are arranged in the order from the most to the least significant bits, where the most significant block of bits is a key used to access child node of the root. Each following key is used to find a child node on the corresponding tree level.

Knowing the depth at which a node is located and the count of bits per level, the value of the key can be calculated using bitwise operations such as logical shift and masking. Let's take a look at a mechanism used to extract the correct subkey.

In the following example there is a byte which represents a key equal to 54. Let's assume that it belongs to the tree where \m{} is 4, \x{} is 2 and \h\ is 3.

\begin{equation}
    54_{10} = 00110110_2
\end{equation}

Since there are three levels, we have only three subkeys: $11_2$, $01_2$ and $10_2$. Let's say that we are interested in extracting subkey for the child node on the second level or $01_2$.

First, let's get rid of the bits following the subkey of our interest. Logical right shift operation\footnote{A logical right shift is a bitwise operation that shifts all the bits of its first operand to the right by number of bits specified in the second operand.} denoted as $\ggg$, will push specified count of 0s into key $k$, where $l$ is the \emph{level} at which current node is located:

\begin{equation}
    k \ggg ((l - 1) * x).
\end{equation}

The key $k$ will be shifted by 2 bits, because the node from the example is located at $l = 2$ in the tree of $x = 2$. The result of operation is $00001101_2$. As the result, the "tail" of the key is truncated.

The next step is to get rid of bits preceding the subkey by masking them to 0. An operator used for this is known as bitwise "and" and it will be applied to the result of shifting operation.

A bitwise "and" takes two equal-length binary representations and executes the "and" operation for each pair of the corresponding bits. If both bits in the compared position are 1, the bit in the resulting binary representation is 1; otherwise, the result is 0. Here is an example, where the first and the second operands are the key and mask respectively:

\begin{equation}
    00001101 \ \& \ 00000011 = 00000001.
\end{equation}

Only the last two bits of the mask are set to 1, which means that all bits of the key except last two will be masked to 0. The result of the "and"-ing operation will be the value of the subkey.

A mask must be of the same type as a key and can be calculated from the branching factor \m:

\begin{equation}
    \mathit{mask} = m - 1.
\end{equation}

If \m{} is equal to 4, the maximum subkey value will be 3, which equals to 00000011\ts{2}.

\begin{figure}
    \caption{Visualization of the radix search algorithm.}
    \label{fig:rb-tree-example-1}

    % TODO: font=\ttfamily
    \centering
    \begin{tikzpicture} [
        node/.style = {
            matrix of nodes,
            nodes = { draw, minimum width = 6mm, minimum height = 8mm, anchor = center},
            font = \small,
            nodes in empty cells
        },
        value/.style = {
            matrix of nodes,
            nodes = { draw = none, minimum width = 4mm, minimum height = 4mm, anchor = center, rotate = 90 },
            font = \small,
            nodes in empty cells
        },
        edge/.style = { ->, shorten >= 4pt }
    ]
        \node[] (index) at (current page.north west) { $104_{10}$ = $01 10 10 00_{2}$ };

        \matrix[node] (node-1-1) [below right = 8mm and 1cm of index] { 00 & 01 & 10 & 11 \\ };

        \scoped[on background layer] {
            \node[fit=(node-1-1-1-1), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-1-1-1-2), fill=color-path, inner sep = 0pt]   {};
            \node[fit=(node-1-1-1-3), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-1-1-1-4), fill=color-node, inner sep = 0pt]   {};
        }

        \matrix[node, inner sep = 0pt] (node-2-2) [below left = 8mm and 1mm of node-1-1.south] { 00 & 01 & 10 & 11 \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-2-3) [below right = 8mm and 1mm of node-1-1.south] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-2-1) [left = 2mm of node-2-2.west] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-2-4) [right = 2mm of node-2-3.east] { & & & \\ };

        \scoped[on background layer] {
            \node[fit=(node-2-2-1-1), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-2-2-1-2), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-2-2-1-3), fill=color-path, inner sep = 0pt]   {};
            \node[fit=(node-2-2-1-4), fill=color-node, inner sep = 0pt]   {};
        }

        \draw[edge, out=225, in=45] (node-1-1-1-1.south) to (node-2-1.north);
        \draw[edge, out=225, in=45] (node-1-1-1-2.south) to (node-2-2.north);
        \draw[edge, out=315, in=135] (node-1-1-1-3.south) to (node-2-3.north);
        \draw[edge, out=315, in=135] (node-1-1-1-4.south) to (node-2-4.north);

        \matrix[node, fill = color-node, inner sep = 0pt] (node-3-2) [below left = 8mm and 1mm of node-2-2.south] { & & & \\ };
        \matrix[node, inner sep = 0pt] (node-3-3) [below right = 8mm and 1mm of node-2-2.south] { 00 & 01 & 10 & 11 \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-3-1) [left = 2mm of node-3-2.west] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-3-4) [right = 2mm of node-3-3.east] { & & & \\ };

        \scoped[on background layer] {
            \node[fit=(node-3-3-1-1), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-3-3-1-2), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-3-3-1-3), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-3-3-1-4), fill=color-path, inner sep = 0pt]   {};
        }

        \draw[edge, out=225, in=45] (node-2-2-1-1.south) to (node-3-1.north);
        \draw[edge, out=225, in=45] (node-2-2-1-2.south) to (node-3-2.north);
        \draw[edge, out=315, in=135] (node-2-2-1-3.south) to (node-3-3.north);
        \draw[edge, out=315, in=135] (node-2-2-1-4.south) to (node-3-4.north);

        \matrix[node, fill = color-node, inner sep = 0pt] (node-4-2) [below left = 8mm and 1mm of node-3-3.south] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-4-3) [below right = 8mm and 1mm of node-3-3.south] { & & & \\ };
        \matrix[node, fill = color-node, inner sep = 0pt] (node-4-1) [left = 2mm of node-4-2.west] { & & & \\ };
        \matrix[node, inner sep = 0pt] (node-4-4) [right = 2mm of node-4-3.east] { 00 & 01 & 10 & 11 \\ };

        \scoped[on background layer] {
            \node[fit=(node-4-4-1-1), fill=color-path, inner sep = 0pt]   {};
            \node[fit=(node-4-4-1-2), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-4-4-1-3), fill=color-node, inner sep = 0pt]   {};
            \node[fit=(node-4-4-1-4), fill=color-node, inner sep = 0pt]   {};
        }

        \draw[edge, out=225, in=45] (node-3-3-1-1.south) to (node-4-1.north);
        \draw[edge, out=225, in=45] (node-3-3-1-2.south) to (node-4-2.north);
        \draw[edge, out=315, in=135] (node-3-3-1-3.south) to (node-4-3.north);
        \draw[edge, out=315, in=135] (node-3-3-1-4.south) to (node-4-4.north);

        \matrix[value] (node-5-1) [below = 0mm of node-4-1.south] { 139 & 140 & 141 & 142 \\ };
        \matrix[value] (node-5-2) [below = 0mm of node-4-2.south] { 143 & 144 & 145 & 146 \\ };
        \matrix[value] (node-5-3) [below = 0mm of node-4-3.south] { 147 & 148 & 149 & 150 \\ };
        \matrix[value] (node-5-4) [below = 0mm of node-4-4.south] { 151 & 152 & 153 & 154 \\ };
    \end{tikzpicture}
\end{figure}

Let's put everything together and review the radix search step by step based on the concrete example. In \Cref{fig:rb-tree-example-1}, we can see a part of the \rbtree{} which represents elements of persistent vector in the range [92, 107].

The branching factor of the tree is equal to 4, which means that 2 bits will be used for the subkey representation. The mask is equal to 3 or 00000011 in the binary representation.

The index is of the \emph{unsigned byte} type, which has a capacity\footnote{The capacity of any integer type can be calculated by taking the base of the binary system to the power of bits available for its representation. For unsigned byte, it will be $2^8 = 256$.} of 256. In practice, the index type is usually a 32 or a 64 bit integer, which has significantly bigger capacity.

The height of the tree in \Cref{fig:rb-tree-example-1} is 4. The goal is to lookup the contents of an element corresponding to the key 104, which is equal to 01101000\ts{2}. \Cref{lst:rb-tree-radix-search} outlines the radix search algorithm implementation.

The search process starts by initializing the node and level variables to root and $height - 1$ correspondingly. The for loop runs until the leaf node level is reached, where each step towards it involves selecting a child node by using bit shifting and masking. After exiting the for loop, function returns the value from the leaf node.

\begin{listing}[ht!]
    \caption{Pseudocode for RB-Tree's radix search implementation.}
    \label{lst:rb-tree-radix-search}

    \begin{algorithmic}
        \Function{RbTree-Radix-Search}{root, key}
            \State node \la\ root

            \For{level \la\ root\ts{height} - 1, 1}
                \State index \la\ (key $\ggg$ (level * x)) \& mask
                \State node \la\ node[index]
            \EndFor

            \State index \la\ key \& mask
            \State \Return {node[index]}
        \EndFunction
    \end{algorithmic}
\end{listing}

\subsection{Update}
A function for replacing values in \rbtree{} is called \emph{update}. Emphemeral update is \emph{destructive}, meaning that the original \emph{version} of the data structure will be no longer available after the operation is executed. For \emph{persistent data structures}, update results in the new \emph{version} including the updated value without the original becoming unavailable.

Version is something that differentiates one instance of the \rbtree{} from another. Instead of using explicit versioning such as assigning unique identifiers to instances of \rbtree{}, we will rely on a memory address as a unique identifier.

\subsubsection*{Path copying}
% PATH COPYING AND COPY-ON-WRITE behavior

% Logically each node is a copy-on-write array that contains subtrees or elements.
% To minimize copying while retaining full persistence, we perform path copying: We copy all nodes on the path down to the value we’re about to update or insert and replace the value with the new one when we’re at the bottom.

Radix search is used to find the value corresponding to the given key. In order to ensure that the original version of \rbtree\ stays unmodified, each node on the way down from the root to the value will be copied. This process is also know as \emph{path copying} \cite{planar-point-location}. It is important to emphasize that nodes which are not a part of the path are reused, instead of being recreated.

In order to get a sense of how well path copying performs, let’s review the whole process in reverse. The leaf node update creates a copy of underlying array of size \m{}. Then, the \m{} sized parent branch node is copied as well, where the fresh copy of the leaf is used instead of the original. The other children of the parent are reused. The same process applies to the grand parent and so on all the way up to the root.

To summarize, the update operation performs the \h{} count copies of \m{} sized nodes, where \h{} is the maximum height of the tree. As described in \Cref{eq:h-max}, \h{} is bound by \bigo{log_m(n)}, which results in {\bigo{m * log_m(n)}} complexity of the update operation.

For large branching factors \m\ such as 32, the performance becomes \bigo{1} in practice. For example, if the tree is completely full, where the count of all elements $n$ is bound by the maximum value of 32 bit integer\footnote{2147483647}, \h{} will be at most 7.

\begin{listing}[ht!]
    \caption{Pseudocode for RB-Tree's update implementation.}
    \label{lst:rb-tree-update}

    \begin{algorithmic}
        \Function{RbTree-Update}{root, key, value}
            \State newRoot \la\ clone(root)
            \State node \la\ newRoot

            \For{level \la\ root\ts{h} - 1, 1}
                \State index \la\ (key $\ggg$ (level * x)) \& mask
                \State newChildNode \la\ Clone(node[index])
                \State node[index] \la\ newChildNode
                \State node \la\ newChildNode
            \EndFor

            \State index \la\ key \& mask
            \State node[index] \la\ value
            \State \Return newRoot
        \EndFunction
    \end{algorithmic}
\end{listing}

From the implementation standpoint, the main difference between update and radix search is that every visited node must be copied, including root. The return value is the root node for the new version of the tree.


\subsection{Push}
% This are not references, but values themselves
References to values are stored at the leaf nodes of the tree. If the number of values stored in the structure is less than branching factor, then the root node itself will be a leaf. Otherwise, capacity of the tree is increased by adding intermediate branch nodes.


The push operation is used to add new elements to the \rbtree{}. It employs the \emph{path copying} mechanism to minimize the cost and maximize performance of the operation. It accepts a root node and a new value as arguments, and returns a new version of the tree.

A key for the new element is equal to the count of elements in \rbtree{}, also known as the \emph{size} of the tree. For example, if the size is 9, the key for the new value will also be 9. The size will be incremented after the operation is executed.

The main difference between the update and the push operation is that the latter one has to take care of allocating more space for new elements. If the rightmost leaf node has available slots, then behavior of push is very similar to update. Otherwise, there are two additional scenarios in which either the rightmost leaf is completely full or there is no more space left in the root node.

The solution for the first case comes from radix search. Given a unique key, radix search calculates a path that never leads to a full leaf node. What might happen is that a path will include nodes which are not created yet. This can be solved by generating them on demand.

The second case, also known as \emph{root overflow}, occurs when the \emph{size} of the tree exceeds its \emph{capacity}. Capacity is the maximum number of elements a tree can accommodate, which can be calculated based on the height \h{} and the branching factor \m{} of \rbtree{}:

\begin{equation}
	c = m^h.
\end{equation}

The implementation of this calculation is based on the left bit shift operation, described in \Cref{lst:rb-tree-capacity}.

The Root overflow can be solved by adding a new level to the tree. This is done by creating a new root node and setting the old root as the first child of the new root. The rest is handled by generating new nodes in the path to the new value. For more details, see \Cref{lst:rb-tree-push}.

\begin{listing}[ht!]
    \caption{Pseudocode for RB-Tree's capacity implementation.}
    \label{lst:rb-tree-capacity}

    \begin{algorithmic}
        \Function{RbTree-Capacity}{height}
		\State \Return m $\ll$ ((height - 1) * x)
        \EndFunction
    \end{algorithmic}
\end{listing}

\begin{listing}[ht!]
    \caption{Pseudocode for RB-Tree's push implementation}
    \label{lst:rb-tree-push}

    \begin{algorithmic}
        \Function{Rb-Tree-Push}{root, value}
            \State newRoot \la\ \nil{}

            \If{RbTree-Capacity(root\ts{height}) <= root\ts{size}}
                \State newRoot \la\ Create-Node()
                \State newRoot[0] \la\ Clone(root)
                \State newRoot\ts{height} \la\ root\ts{height} + 1
            \Else
                \State newRoot \la\ Clone(root)
            \EndIf

            \State node \la\ newRoot
            \State key \la\ newRoot\ts{size}

            \For{level \la\ newRoot\ts{height} - 1, 1}
                \State index \la\ (key $\ggg$ (level * x)) \& mask

                \State childNode \la\ node[index]
                \State newChildNode \la\ \nil{}

                \If{childNode = \nil{}}
                    \State newChildNode \la\ Create-Node()
                \Else
                    \State newChildNode \la\ Clone(childNode)
                \EndIf

                \State node[index] \la\ newChildNode
                \State node \la\ newChildNode
            \EndFor

            \State index \la\ key \& mask
            \State node[index] \la\ value

            \State newRoot\ts{size} \la\ newRoot\ts{size} + 1
            \State \Return newRoot
        \EndFunction
    \end{algorithmic}
\end{listing}

\subsection{Pop}
Pop is used to remove items from the \rbtree. Together with push, it conforms to the LIFO\footnote{Last In First Out} principle which is typical for the stack abstract data type. It accepts root as input and returns both a popped value and a new version of a structure.

Pop is responsible for reducing capacity of the \rbtree{}, including removal of branch and leaf nodes when they become empty. As with other operations, modifications are kept to the minimum by taking advantage of path copying algorithm.

\begin{listing}[ht!]
    \caption{Pseudocode for RB-Tree's pop implementation}
    \label{lst:rb-tree-pop}

    \begin{algorithmic}
        \Function{RbTree-Pop-Node}{node, key}
            \State newNode \la\ Clone(node)
            \State value \la\ \nil{}

            \If{node\ts{height} = 0}
                \State index \la\ key \& mask
                \State value \la\ newNode[index]
                \State newNode[index] \la\ \nil{}
            \Else
                \State index \la\ (key $\ggg$ (newNode\ts{height} * x)) \& mask
                \State value, childNode \la\ RbTree-Pop-Node(newNode[index], key)
                \State newNode[index] \la\ childNode
            \EndIf

            \If{newNode[0] = \nil{}}
                \State \Return value, \nil{}
            \Else
                \State \Return value, newNode
            \EndIf
        \EndFunction
        \State
        \Function{Pop}{root}
            \State value, newRoot \la\ RbTree-Pop-Node(root, root\ts{size} - 1)

            \If{newRoot[1] = \nil{})}
                \State newRoot \la\ newRoot[0]
            \EndIf

            \State \Return value, newRoot
        \EndFunction
    \end{algorithmic}
\end{listing}

Since the \rbtree{} is a complete\footnote{A complete n-ary tree is an n-ary tree which is maximally space efficient. It must be completely filled on every level except for the last level. However, if the last level is not complete, then all nodes of the tree must be "as far left as possible".} tree, all entries to the right of \nil{} must be absent as well. As shown in \Cref{lst:rb-tree-pop}, checking if the first entry is \nil{} is sufficient to understand if a node must be removed. If it is true, the empty child will be replaced with a \nil{} reference in the parent node.

A root is considered to be redundant if it contains only a single child node, which is true if the second entry is \nil{}.  The original root is demoted by replacing it with the first child node, which becomes the new root.

\subsection{Tail optimization for persistent vector}
\label{sec:tail-optimization}

In practice, changes are often applied to the end or \emph{tail} of the data structure. Stack is specifically optimized for such use cases, by offering the constant performance for the push and pop operations. Even though \rbtree\ has similar performance characteristics, its push and pop implementations include pesky constant factors in the form of \emph{radix search} and \emph{path copying} algorithms.

The \emph{tail} optimization is intended to offset this cost by reducing the count of the \rbtree\ accesses. Instead of adding or removing elements one by one, changes are batched in the array of size \m. This array could be thought of as a leaf node, which will be attached to the tree only when it is full.

\subsubsection*{Optimizing the push operation}
As shown in \Cref{lst:pvec-push}, the value is set into a cloned tail at the position tail\ts{size}. Since \rbtree\ is a complete tree, the rightmost leaf node is the only node which can be empty or semi-full. As the tail is the rightmost leaf node, its size is as an index for the new value.

If after update the tail is full, it will be pushed into a tree and replaced with an empty tail.

\begin{listing}[ht!]
    \caption{Tail optimization for persistent vector’s push implementation.}
    \label{lst:pvec-push}

    \begin{algorithmic}
        \Function{Pvec-Push}{vec, value}
        \State newTail \la\ Clone(vec\ts{tail})
        \State newTail[tail\ts{size}] \la\ value
        \State newTail\ts{size} \la\ tail\ts{size} + 1
        \State newRoot \la\ vec\ts{root}

        \If{newTail\ts{size} = m}
            \State newRoot \la\ RbTree-Push(vec\ts{root}, newTail)
            \State newTail \la\ Create-Node()
        \EndIf

        \State \Return Create-Vec(newRoot, newTail)
        \EndFunction
    \end{algorithmic}
\end{listing}

\subsubsection*{Optimizing the pop operation}
Since the tail might contain elements, pop has to remove them first before touching the \rbtree. If the tail is empty, it will be replaced with the rightmost leaf of \rbtree. See \Cref{lst:pvec-pop} for more details.

\begin{listing}[ht!]
    \caption{Tail optimization for persistent vector’s pop implementation}
    \label{lst:pvec-pop}

    \begin{algorithmic}
        \Function{Pvec-Pop}{vec}

        \State newTail \la\ Clone(vec\ts{tail})
        \State newRoot \la\ \nil{}

        \State value \la\ newTail[newTail\ts{size} - 1]
        \State newTail\ts{size} \la\ newTail\ts{size} - 1

        \If{newTail\ts{size} = 0}
            \State newRoot, newTail \la\ RbTree-Pop(vec\ts{root})
        \Else
            \State newRoot \la\ vec\ts{root}
        \EndIf

        \State \Return Create-Vec(newRoot, newTail)
        \EndFunction
    \end{algorithmic}
\end{listing}

\subsubsection*{Adapting the update and radix search operations}
Changes for both update and radix search are very similar, with the difference that update has to ensure that the original version of vector stays unmodified.

The radix search implementation has to take into account that some of the values can be in the tail. A value is located within the tree if the key is less than the tree size. In this case the search process is delegated to \rbtree. Otherwise, the index for value in the tail is calculated by subtracting the tree size from the key.

\begin{listing}[ht!]
    \caption{Adapting the update operation to support tail}
    \label{lst:pvec-update}

    \begin{algorithmic}
        \Function{Pvec-Update}{vec, key, value}

        \State root \la\ vec\ts{root}
        \State tail \la\ vec\ts{tail}

        \If{key < root\ts{size}}
            \State newRoot \la\ RbTree-Update(root, key, value)
            \State \Return Create-Vec(newRoot, tail)
        \Else
            \State newTail \la\ Clone(tail)
            \State newTail[key - root\ts{size}] \la\ value
            \State \Return Create-Vec(root, newTail)
        \EndIf
        \EndFunction
    \end{algorithmic}
\end{listing}

\begin{listing}[ht!]
    \caption{Adapting the radix search operation to support tail}
    \label{lst:pvec-radix-search}

    \begin{algorithmic}
        \Function{Pvec-Radix-Search}{vec, key}

        \State root \la\ vec\ts{root}
        \State tail \la\ vec\ts{tail}

        \If{key < root\ts{size}}
            \State \Return RbTree-Radix-Search(root, key)
        \Else
            \State \Return tail[key - root\ts{size}]
        \EndIf
        \EndFunction
    \end{algorithmic}
\end{listing}

\section{Relaxed radix balanced tree}
% A couple of words here on what is RRB-Tree, what it offers, and how is it different compared to RB-Tree.
%  * A confluent persistent data structure.
%  * Relaxation as a way to achieve efficient concatenation and splitting.

% Then, say what this chapter is about:
%  * Which constraints are relaxed and which constraints are enforced:
%   * The relaxed child count and completeness of nodes
%   * How does RRB-Tree guarantee that height won't exceed certain limits
%  * The concatenation and splitting algorithms.
%  * Changing the following algorithms to accommodate relaxed constraints:
%   * Radix search

Relaxed radix balanced tree or \treerrb{}, extends \treerb{} to support concatenation and splitting in \bigo{log(n)} rather than linear time without compromising the performance of other operations.

An invariant that \treerb{} maintains is that all nodes except the right-most ones have to be full. This enables a simple radix search implementation, but on the other hand, makes efficient sub-linear concatenation impossible.

The \treerrb{} relaxes this constraint by allowing nodes to be partially full, and introduces a rebalancing algorithm to ensure that the tree height does not exceed the \bigo{log(n)} bound to keep performance guarantees for other operations.

In this section, we will take a look at how \treerrb{} works, specifically the concatenation algorithm and the relaxed variant of the radix search.

\subsection{Memory layout}
With relaxed \treerrb{} constraints, there is no reliable way to calculate the size of the subtree without additional metadata. Hence, the \emph{sizes} array is introduced to keep track of the subtree size. The \emph{sizes} array is \m{} elements long, where each value represents the subtree size at the corresponding index. The sizes table values are re-calculated when the subtree is modified, for example, when concatenating or pushing new values.

\subsection{Relaxed radix search}
When \treerb{} is relaxed, it is no longer possible to compute indices from a search key without additional metadata in the form of \emph{size} tables. Each entry of the size table is an accumulated number of values in the corresponding subtree.

When the radix search encounters a relaxed node, it compares the entire search key against entries in the size table. A subtree contains the desired value if the corresponding size table entry is bigger than or equal to the search key. Before descending into a subtree and repeating the search step, the search key is subtracted the size of the subtree.

When a balanced node is encountered, the search process falls back to the balanced version of the radix search algorithm \Cref{sec:rb-tree-radix-search}.

\begin{listing}[!ht]

    \begin{algorithmic}[1]
        \Function{FindIndex}{sizes, idx}
            \State candidate \la 0

            \If{candidate < \m\ - 1 \And\ sizes[candidate] <= idx}
                \State candidate++
            \EndIf

            \State \Return candidate
        \EndFunction

        \State

        \Function{RelaxedRadixSearch}{root, key}
            \State node \la\ root
            \State idx \la\ key

            \For{level \la\ root\ts{height} - 1, 1}
                \If{node\ts{sizes}=\nil{}}
                    \State index \la\ (key $\ggg$ (level * x)) \& mask
                    \State node \la\ node[index]
                \Else
                    \State sizes \la\ node\ts{sizes}
                    \State index \la\ \Call{FindIndex}{sizes, idx}
                    \State node \la\ node[index]

                    \If{index != 0}
                        \State idx \la\ idx - sizes[index - 1]
                    \EndIf
                \EndIf
            \EndFor

            \State index \la\ idx \& mask
            \State \Return {node[index]}
        \EndFunction
    \end{algorithmic}

    \caption{Pseudocode of relaxed radix search}
    \label{lst:rrb-tree-relaxed-radix-search}
\end{listing}

\subsection{Concatenation}
The concatenation algorithm used in this project is from \cite{rrb-vector-practical-general-purpose-im-sequence}, which produces a slightly more balanced tree than initially proposed by \cite{efficient-immutable-vectors}. It achieves it by allowing the relaxed tree nodes to have \m{} children instead of $\m{} - 1$.

The algorithm consists of two stages: descending the tree, and then, merging and rebalancing nodes. The time complexity of the presented concatenation algorithm is \bigo{m^2 \cdot{} log_m(n)}.

The recursive function in Listing \ref{lst:rrb-tree-concatenation} descends the tree by selecting the rightmost node of the left tree and the leftmost node of the right tree. If one of the trees is taller than the other, the function descends into a taller tree only until nodes of both trees are at the same level.

When the bottom level with leaf nodes is reached, the function stops descending and starts merging and rebalancing nodes to ensure the \bigo{log_m(n)} bound on the tree height.

\begin{listing}[!ht]
    \begin{algorithmic}[1]
        \Function{Concat}{leftNode, rightNode}
            \If{leftNode\ts{height} > rightNode\ts{height}}
                \State mergedNode \la\ \Call{Concat}{leftNode\ts{last}, rightNode}
                \State \Return \Call{Rebalance}{leftNode\ts{init}, mergedNode, \nil{}}
            \ElsIf{leftNode\ts{height} < rightNode\ts{height}}
                \State mergedNode \la\ \Call{Concat}{leftNode, rightNode\ts{first}}
                \State \Return \Call{Rebalance}{\nil{}, mergedNode, rightNode\ts{tail}}
            \Else
                \State mergedNode \la\ \nil{}

                \If{leftNode\ts{height}=0}
                    \State mergedNode \la\ \Call{Concat}{leftNode, rightNode}
                \Else
                    \If{leftNode\ts{height}=1}
                        \State mergedNode \la\ \Call{Concat}{leftNode\ts{last}, rightNode\ts{first}}
                    \Else
                        \State mergedNode \la\ \Call{Concat}{leftNode\ts{last}, rightNode\ts{first}}
                    \EndIf
                \EndIf

                \State \Return \Call{Rebalance}{leftNode\ts{init}, mergedNode, rightNode\ts{tail}}
            \EndIf
        \EndFunction
    \end{algorithmic}

    \caption{Concatenation algorithm of \treerrb{}}
    \label{lst:rrb-tree-concatenation}
\end{listing}

The \textproc{Rebalance} function accepts three lists of nodes as arguments. The \texttt{left} and \texttt{right} lists constitute all nodes of both trees at the given level except two: the rightmost node of the left tree and the leftmost node of the right tree. Those two nodes are already rebalanced and passed as the \texttt{middle} argument. Three lists are concatenated together into a single \texttt{merged} list.

The goal of rebalancing is to arrange the children of \texttt{merged} nodes in such a way that all nodes except the rightmost branch are filled with values. When the \textproc{Rebalance} function completes re-arranging nodes, it returns a new branch containing rebalanced nodes. Pseudocode for rebalancing can be found in Appendix \ref{lst:rrb-tree-rebalance}.

The rebalancing process is illustrated in Figures \ref{fig:rrb-tree-rebalance-level-0}-\ref{fig:rrb-tree-rebalance}. Note, presented figures exclude parts of trees that are not important for conveying the idea to preserve space.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text depth=.25ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colorleft] (left-1-1) at (current page.north west) { & & & \\ };

        \matrix[node, fill=colorleft] (left-2-4) [below right=8mm and 1mm of left-1-1.south] { & & \\ };
        \node (left-2-3) [left=2mm of left-2-4.west] { \ldots };
        \node (left-2-2) [left=2mm of left-2-3.west] { \ldots };
        \node (left-2-1) [left=2mm of left-2-2.west] { \ldots };

        \draw[edge-dashed, out=225, in=45] (left-1-1-1-1.south) to (left-2-1.north);
        \draw[edge-dashed, out=225, in=45] (left-1-1-1-2.south) to (left-2-2.north);
        \draw[edge-dashed, out=225, in=75] (left-1-1-1-3.south) to (left-2-3.north);
        \draw[edge, out=315, in=90] (left-1-1-1-4.south) to (left-2-4.north);

        \matrix[node, fill=colorleft] (left-3-2) [below left=8mm and 1mm of left-2-4.south] { e & f & g & h \\ };
        \matrix[node, fill=colorleft] (left-3-3) [below right=8mm and 1mm of left-2-4.south] { i & j \\ };
        \matrix[node, fill=colorleft] (left-3-1) [left=2mm of left-3-2.west] { a & b & c & d \\ };

        \draw[edge, out=225, in=45] (left-2-4-1-1.south) to (left-3-1.north);
        \draw[edge, out=225, in=45] (left-2-4-1-2.south) to (left-3-2.north);
        \draw[edge, out=315, in=90] (left-2-4-1-3.south) to (left-3-3.north);

        \matrix[node, fill=colorright] (right-1-1) [right=56mm of left-1-1.east] { & \\ };
        \matrix[node, fill=colorright] (right-2-1) [below left=8mm and 1mm of right-1-1.south] { & & & \\ };
        \node (right-2-2) [right=2mm of right-2-1.east] { \ldots };

        \draw[edge, out=225, in=90] (right-1-1-1-1.south) to (right-2-1.north);
        \draw[edge-dashed, out=315, in=90] (right-1-1-1-2.south) to (right-2-2.north);

        \matrix[node, fill=colorright] (right-3-2) [below left=8mm and 1mm of right-2-1.south] { o & p & q & r \\ };
        \matrix[node, fill=colorright] (right-3-3) [below right=8mm and 1mm of right-2-1.south] { s & t & u & v \\ };
        \matrix[node, fill=colorright] (right-3-1) [left=2mm of right-3-2.west] { k & l & m & n \\ };
        \matrix[node, fill=colorright] (right-3-4) [right=2mm of right-3-3.east] { w & x & y & z \\ };

        \draw[edge, out=225, in=45] (right-2-1-1-1.south) to (right-3-1.north);
        \draw[edge, out=225, in=45] (right-2-1-1-2.south) to (right-3-2.north);
        \draw[edge, out=315, in=135] (right-2-1-1-3.south) to (right-3-3.north);
        \draw[edge, out=315, in=135] (right-2-1-1-4.south) to (right-3-4.north);

        \node[draw, dashed, inner sep=1mm, fit=(left-3-3) (left-3-3) (right-3-1) (left-3-3)] {};
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm at level 0}
    \label{fig:rrb-tree-rebalance-level-0}
\end{figure}

Concatenation starts at the bottom of the tree by merging the leaf nodes. The result is a new rebalanced branch with leaves that will be used when rebalancing nodes at level 1.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}
    \colorlet{colormerged}{orange!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text depth=.25ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colorleft] (left-1-1) at (current page.north west) { & & & \\ };

        \matrix[node, fill=colorleft] (left-2-4) [below right=8mm and 1mm of left-1-1.south] { & \\ };
        \node (left-2-3) [left=2mm of left-2-4.west] { \ldots };
        \node (left-2-2) [left=2mm of left-2-3.west] { \ldots };
        \node (left-2-1) [left=2mm of left-2-2.west] { \ldots };

        \draw[edge-dashed, out=225, in=45] (left-1-1-1-1.south) to (left-2-1.north);
        \draw[edge-dashed, out=225, in=45] (left-1-1-1-2.south) to (left-2-2.north);
        \draw[edge-dashed, out=225, in=75] (left-1-1-1-3.south) to (left-2-3.north);
        \draw[edge, out=315, in=90] (left-1-1-1-4.south) to (left-2-4.north);

        \matrix[node, fill=colorleft] (left-3-2) [below right=8mm and 1mm of left-2-4.south] { e & f & g & h \\ };
        \matrix[node, fill=colorleft] (left-3-1) [left=2mm of left-3-2.west] { a & b & c & d \\ };

        \draw[edge, out=225, in=45] (left-2-4-1-1.south) to (left-3-1.north);
        \draw[edge, out=315, in=90] (left-2-4-1-2.south) to (left-3-2.north);

        \matrix[node, fill=colormerged] (merged-1-1) [right=32mm of left-2-4.east] { & \\ };
        \matrix[node, fill=colormerged] (merged-2-1) [below left=8mm and 1mm of merged-1-1.south] { i & j & k & l \\ };
        \matrix[node, fill=colormerged] (merged-2-2) [below right=8mm and 1mm of merged-1-1.south] { m & n \\ };

        \draw[edge, out=225, in=90] (merged-1-1-1-1.south) to (merged-2-1.north);
        \draw[edge, out=315, in=90] (merged-1-1-1-2.south) to (merged-2-2.north);

        \matrix[node, fill=colorright] (right-1-1) [right=72mm of left-1-1.east] { & \\ };
        \matrix[node, fill=colorright] (right-2-1) [below left=8mm and 1mm of right-1-1.south] { & & \\ };
        \node (right-2-2) [right=2mm of right-2-1.east] { \ldots };

        \draw[edge, out=225, in=90] (right-1-1-1-1.south) to (right-2-1.north);
        \draw[edge-dashed, out=315, in=90] (right-1-1-1-2.south) to (right-2-2.north);

        \matrix[node, fill=colorright] (right-3-1) [below left=8mm and 1mm of right-2-1.south] { o & p & q & r \\ };
        \matrix[node, fill=colorright] (right-3-2) [right=2mm of right-3-1.east] { s & t & u & v \\ };
        \matrix[node, fill=colorright] (right-3-3) [right=2mm of right-3-2.east] { w & x & y & z \\ };

        \draw[edge, out=225, in=45] (right-2-1-1-1.south) to (right-3-1.north);
        \draw[edge, out=315, in=135] (right-2-1-1-2.south) to (right-3-2.north);
        \draw[edge, out=315, in=135] (right-2-1-1-3.south) to (right-3-3.north);

        \node[draw, dashed, inner sep=1mm, fit=(merged-1-1) (merged-1-1) (left-2-4) (right-2-1)] {};
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm at level 1}
    \label{fig:rrb-tree-rebalance-level-1}
\end{figure}

Rebalancing at level 1 involves the left and right branches together with the newly created branch from the previous step. The algorithm avoids processing nodes where rebalancing is not beneficial. For example, in Figure \ref{fig:rrb-tree-rebalance-level-2} where the \emph{full} nodes from the left-hand side tree are re-used without rebalancing them.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}
    \colorlet{colormerged}{orange!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text depth=.25ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colorleft] (left-1-1) at (current page.north west) { & & \\ };

        \node (left-2-3) [left=2mm of left-2-4.west] { \ldots };
        \node (left-2-2) [left=2mm of left-2-3.west] { \ldots };
        \node (left-2-1) [left=2mm of left-2-2.west] { \ldots };

        \draw[edge-dashed, out=225, in=45] (left-1-1-1-1.south) to (left-2-1.north);
        \draw[edge-dashed, out=225, in=45] (left-1-1-1-2.south) to (left-2-2.north);
        \draw[edge-dashed, out=225, in=75] (left-1-1-1-3.south) to (left-2-3.north);

        \matrix[node, fill=colormerged] (merged-1-1) [right=38mm of left-1-1.east] { & \\ };
        \matrix[node] (merged-2-1) [below left=8mm and 22mm of merged-1-1.south] { & & & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-2-1-1-1), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-2), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-3), fill=colormerged, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-4), fill=colormerged, inner sep=0pt] {};
        }

        \matrix[node, fill=colormerged] (merged-2-2) [below right=8mm and 22mm of merged-1-1.south] { & & \\ };

        \matrix[node, fill=colorleft] (merged-3-2) [below left=8mm and 1mm of merged-2-1.south] { e & f & g & h \\ };
        \matrix[node, fill=colormerged] (merged-3-3) [below right=8mm and 1mm of merged-2-1.south] { i & j & k & l \\ };
        \matrix[node, fill=colorleft] (merged-3-1) [left=2mm of merged-3-2.west] { a & b & c & d \\ };
        \matrix[node, fill=colormerged] (merged-3-4) [right=2mm of merged-3-3.east] { m & n & o & p \\ };

        \draw[edge, out=225, in=45] (merged-2-1-1-1.south) to (merged-3-1.north);
        \draw[edge, out=225, in=45] (merged-2-1-1-2.south) to (merged-3-2.north);
        \draw[edge, out=315, in=135] (merged-2-1-1-3.south) to (merged-3-3.north);
        \draw[edge, out=315, in=135] (merged-2-1-1-4.south) to (merged-3-4.north);

        \matrix[node, fill=colormerged] (merged-3-6) [below right=8mm and 1mm of merged-2-2.south] { u & v & w & x \\ };
        \matrix[node, fill=colormerged] (merged-3-7) [right=2mm of merged-3-6.east] { y & z \\ };
        \matrix[node, fill=colormerged] (merged-3-5) [left=2mm of merged-3-6.west] { q & r & s & t \\ };

        \draw[edge, out=225, in=90] (merged-1-1-1-1.south) to (merged-2-1.north);
        \draw[edge, out=315, in=90] (merged-1-1-1-2.south) to (merged-2-2.north);

        \draw[edge, out=225, in=45] (merged-2-2-1-1.south) to (merged-3-5.north);
        \draw[edge, out=315, in=135] (merged-2-2-1-2.south) to (merged-3-6.north);
        \draw[edge, out=315, in=135] (merged-2-2-1-3.south) to (merged-3-7.north);

        \matrix[node, fill=colorright] (right-1-1) [right=38mm of merged-1-1.east] { \\ };
        \node (right-2-2) [below right=8mm and 1mm of right-1-1.south] { \ldots };

        \draw[edge-dashed, out=315, in=90] (right-1-1-1-1.south) to (right-2-2.north);

        \node[draw, dashed, inner sep=1mm, fit=(merged-1-1) (merged-1-1) (left-1-1) (right-1-1)] {};
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm at level 2}
    \label{fig:rrb-tree-rebalance-level-2}
\end{figure}

Figure \ref{fig:rrb-tree-rebalance} is the last step that rebalances the top-level nodes of the left and right trees, producing a new root. If the root contains only a single child, its child will be promoted to be the root to avoid unnecessary overhead.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}
    \colorlet{colormerged}{orange!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text depth=.25ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colormerged] (root) at (current page.north) { & \\ };

        \matrix[node] (merged-1-1) [below left=8mm and 8mm of root.south] { & & & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-1-1-1-1), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-1-1-1-2), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-1-1-1-3), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-1-1-1-4), fill=colormerged, inner sep=0pt] {};
        }

        \matrix[node] (merged-1-2) [below right=8mm and 8mm of root.south] { & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-1-2-1-1), fill=colormerged, inner sep=0pt] {};
            \node[fit=(merged-1-2-1-2), fill=colorright, inner sep=0pt] {};
        }

        \draw[edge, out=270, in=75] (root-1-1.south) to (merged-1-1.north);
        \draw[edge, out=270, in=115] (root-1-2.south) to (merged-1-2.north);

        \matrix[node] (merged-2-1) [below left=8mm and 1mm of merged-1-1.south] { & & & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-2-1-1-1), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-2), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-3), fill=colormerged, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-4), fill=colormerged, inner sep=0pt] {};
        }

        \matrix[node, fill=colormerged] (merged-2-2) [below=8mm of merged-1-2.south] { & & \\ };

        \node (merged-left-3) [left=2mm of merged-2-1.west] { \ldots };
        \node (merged-left-2) [left=2mm of merged-left-3.west] { \ldots };
        \node (merged-left-1) [left=2mm of merged-left-2.west] { \ldots };

        \draw[edge-dashed, out=205, in=75] (merged-1-1-1-1.south) to (merged-left-1.north);
        \draw[edge-dashed, out=205, in=55] (merged-1-1-1-2.south) to (merged-left-2.north);
        \draw[edge-dashed, out=205, in=45] (merged-1-1-1-3.south) to (merged-left-3.north);

        \node (merged-right-1) [right=2mm of merged-2-2.east] { \ldots };
        \draw[edge-dashed, out=315, in=105] (merged-1-2-1-2.south) to (merged-right-1.north);

        \matrix[node, fill=colorleft] (merged-3-2) [below left=8mm and 10mm of merged-2-1.south] { e & f & g & h \\ };
        \matrix[node, fill=colormerged] (merged-3-3) [below=8mm of merged-2-1.south] { i & j & k & l \\ };
        \matrix[node, fill=colorleft] (merged-3-1) [left=2mm of merged-3-2.west] { a & b & c & d \\ };
        \matrix[node, fill=colormerged] (merged-3-4) [right=2mm of merged-3-3.east] { m & n & o & p \\ };

        \draw[edge, out=205, in=45] (merged-2-1-1-1.south) to (merged-3-1.north);
        \draw[edge, out=205, in=45] (merged-2-1-1-2.south) to (merged-3-2.north);
        \draw[edge, out=270, in=90] (merged-2-1-1-3.south) to (merged-3-3.north);
        \draw[edge, out=270, in=90] (merged-2-1-1-4.south) to (merged-3-4.north);

        \matrix[node, fill=colormerged] (merged-3-5) [below=8mm of merged-2-2.south] { q & r & s & t \\ };
        \matrix[node, fill=colormerged] (merged-3-6) [right=2mm of merged-3-5.east] { u & v & w & x \\ };
        \matrix[node, fill=colormerged] (merged-3-7) [right=2mm of merged-3-6.east] { y & z \\ };

        \draw[edge, out=225, in=90] (merged-1-1-1-4.south) to (merged-2-1.north);
        \draw[edge, out=315, in=90] (merged-1-2-1-1.south) to (merged-2-2.north);

        \draw[edge, out=270, in=90] (merged-2-2-1-1.south) to (merged-3-5.north);
        \draw[edge, out=270, in=135] (merged-2-2-1-2.south) to (merged-3-6.north);
        \draw[edge, out=315, in=135] (merged-2-2-1-3.south) to (merged-3-7.north);
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm: the rebalanced tree}
    \label{fig:rrb-tree-rebalance}
\end{figure}

The formal description and analysis of concatenation algorithm and its implementation is thoroughly presented in \cite{improving-performance-through-transience}.

\section{Transience}
% TODO
