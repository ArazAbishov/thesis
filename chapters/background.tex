\chapter{Background}

This chapter gives an introduction to the \treerb{} and \treerrb{} data structures that are used as the foundation for persistent vectors:

\begin{itemize}
    \item First, we will take a look at \emph{radix balanced tree}, its organization, and algorithms such as \emph{radix search} and \emph{path copying} that are used at the core of all vector operations.
    \item Then, we will proceed to its extension --- \emph{relaxed radix balanced tree} that enables efficient concatenation and splitting.
    \item Finally, we will get an overview of what is \emph{transience} and how it can be used to improve the performance of persistent data structures.
\end{itemize}

\section{Radix balanced tree}
\label{chapter:radix-balanced-tree}

Radix balanced tree or \treerb{} is an \m{}-ary tree that uses integers as keys to find values. The data structure was pioneered by Rich Hickey as the foundation for the persistent vector implementation in Clojure \cite{the-clojure-programming-language}.

\treerb{} consists of nodes which reference other subtrees or values. We will be referring to the former and latter types of nodes as \emph{branches} and \emph{leaves} correspondingly. The number of subtrees and values in the node is configurable and will be defined as \m{} or the \emph{branching factor}. The branching factor can be any number that is a power of 2, allowing an efficient radix search implementation.

The higher the value of \m{} is, the wider and shallower the tree will be. From now on the height of a tree will be referred to as \h{}, where $h_{max}$ is the upper boundary:

\begin{equation}
    \label{eq:h-max}
    h_{max} = log_m(n)
\end{equation}

When \m{} is a large value, for example, 32, the tree becomes shallow, and the complexity of accessing values by traversing the tree from the root to a leaf becomes \emph{effectively} constant. For example, if the maximum value of 32 bit signed integer is substituted for $n$ in \Cref{eq:h-max} then $h_{max}$ will never exceed 7 levels. Thus, due to its strong performance guarantees, \treerb{} serves as a solid foundation for a general-purpose persistent vector implementation.

In the following sections, we will take a look at \treerb{} algorithms used to implement vector operations\footnote{For a formal definition of \treerb{}, refer to \cite{improving-performance-through-transience}}.

\subsection{Radix search}
\label{sec:rb-tree-radix-search}

An algorithm that is used to lookup values in \treerb{} is called \emph{radix search}. It serves as foundation for other operations that involve the tree traversal, such as push, pop, and update.

\subsubsection*{Bit partitioning}
Radix search accepts a key of the integer type as an argument. It can be thought of as a composite key, where each subkey is a sequence of bits. Conceptually, the idea is to divide the key into bit blocks, where each block is an index specific to the tree level.

As demonstrated in \Cref{eq:bits-per-level}, the bit block size can be calculated from the branching factor. It will be referred to as \x{} or \emph{bits per level}.

\begin{equation}
    \label{eq:bits-per-level}
    x = log_2(m)
\end{equation}

For example, when the branching factor \m{} is 16 \x{} is 4, meaning that the subkey size is equal to 4 bits.

\subsubsection*{Extracting subkeys}
The number of subkeys within the search key depends on the number of tree levels or \h{}. For example, a search key addressing an element of the tree of ${h = 3}$ and ${x = 2}$ will consist of 3 subkeys taking up 6 bits of space in total.

Subkeys are arranged in the order from the most to the least significant bits, where the most significant block of bits is a key used to access the child node of the root. Each following key is used to find a child node on the corresponding tree level.

Let us consider an example of processing a key that addresses a value in the tree of $h = 3$, $m = 4$ and $x = 2$.

\begin{equation}
    54_{10} = 00110110_2
\end{equation}

Since the tree height is three, we have three corresponding subkeys: $11_2$, $01_2$, and $10_2$. Let us assume that we are interested in extracting the subkey for the child node on the second level--$01_2$.

The first step is to get rid of the bits following the subkey of our interest. Logical right shift operation\footnote{A logical right shift is a bitwise operation that shifts all the bits of its first operand to the right by number of bits specified in the second operand.} denoted as $\ggg$, will push specified count of 0s into key $k$, where $l$ is the \emph{level} at which current node is located:

\begin{equation}
    k \ggg ((l - 1) \cdot x).
\end{equation}

Since the node from the example is located at $l = 2$ in the tree of $x = 2$, the key $k$ is shifted by 2 bits. The result of the operation is $00001101_2$. As a result, the "tail" of the key is truncated. The next step is to remove bits preceding the subkey by masking them to 0 using the bitwise "and" operator.

A bitwise "and" takes two equal-length binary representations and executes the "and" operation for each pair of the corresponding bits. If both bits in the compared position are 1, the bit in the resulting binary representation is 1; otherwise, the result is 0. Here is an example, where the first and the second operands are the key and mask respectively:

\begin{equation}
    00001101 \ \& \ 00000011 = 00000001.
\end{equation}

Only the last two bits of the mask are set to 1, meaning that all bits of the key except the last two will be masked to 0. The result of the "and"-ing operation will be the value of the subkey.

A mask must be of the same type as a key and can be calculated from the branching factor \m{}:

\begin{equation}
    \mathit{mask} = m - 1.
\end{equation}

If \m{} is equal to 4, the maximum subkey value will be 3, which equals to 00000011\ts{2}.

\begin{figure}[!ht]
    \colorlet{color-path}{blue!30}
    \colorlet{color-node}{blue!10}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=5mm,minimum height=6mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            nodes in empty cells
        },
        value/.style={
            matrix of nodes,
            nodes={draw=none,minimum width=5mm,minimum height=6mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text width=2.25ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
    ]
        \node[] (index) at (current page.north) { $104_{10}$ = $01 10 10 00_{2}$ };

        \matrix[node] (node-1-1) [below right=8mm and 1cm of index] { 00 & 01 & 10 & 11 \\ };

        \scoped[on background layer] {
            \node[fit=(node-1-1-1-1), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-1-1-1-2), fill=color-path, inner sep=0pt] {};
            \node[fit=(node-1-1-1-3), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-1-1-1-4), fill=color-node, inner sep=0pt] {};
        }

        \matrix[node, inner sep=0pt] (node-2-2) [below left=8mm and 1mm of node-1-1.south] { 00 & 01 & 10 & 11 \\ };
        \matrix[node, fill=color-node] (node-2-3) [below right=8mm and 1mm of node-1-1.south] { & & & \\ };
        \matrix[node, fill=color-node] (node-2-1) [left=2mm of node-2-2.west] { & & & \\ };
        \matrix[node, fill=color-node] (node-2-4) [right=2mm of node-2-3.east] { & & & \\ };

        \scoped[on background layer] {
            \node[fit=(node-2-2-1-1), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-2-2-1-2), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-2-2-1-3), fill=color-path, inner sep=0pt] {};
            \node[fit=(node-2-2-1-4), fill=color-node, inner sep=0pt] {};
        }

        \draw[edge, out=225, in=45] (node-1-1-1-1.south) to (node-2-1.north);
        \draw[edge, out=225, in=45] (node-1-1-1-2.south) to (node-2-2.north);
        \draw[edge, out=315, in=135] (node-1-1-1-3.south) to (node-2-3.north);
        \draw[edge, out=315, in=135] (node-1-1-1-4.south) to (node-2-4.north);

        \matrix[node, fill=color-node] (node-3-2) [below left=8mm and 1mm of node-2-2.south] { & & & \\ };
        \matrix[node, inner sep=0pt] (node-3-3) [below right=8mm and 1mm of node-2-2.south] { 00 & 01 & 10 & 11 \\ };
        \matrix[node, fill=color-node] (node-3-1) [left=2mm of node-3-2.west] { & & & \\ };
        \matrix[node, fill=color-node] (node-3-4) [right=2mm of node-3-3.east] { & & & \\ };

        \scoped[on background layer] {
            \node[fit=(node-3-3-1-1), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-3-3-1-2), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-3-3-1-3), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-3-3-1-4), fill=color-path, inner sep=0pt] {};
        }

        \draw[edge, out=225, in=45] (node-2-2-1-1.south) to (node-3-1.north);
        \draw[edge, out=225, in=45] (node-2-2-1-2.south) to (node-3-2.north);
        \draw[edge, out=315, in=135] (node-2-2-1-3.south) to (node-3-3.north);
        \draw[edge, out=315, in=135] (node-2-2-1-4.south) to (node-3-4.north);

        \matrix[node, fill=color-node] (node-4-2) [below left=8mm and 1mm of node-3-3.south] { & & & \\ };
        \matrix[node, fill=color-node] (node-4-3) [below right=8mm and 1mm of node-3-3.south] { & & & \\ };
        \matrix[node, fill=color-node] (node-4-1) [left=2mm of node-4-2.west] { & & & \\ };
        \matrix[node, inner sep=0pt] (node-4-4) [right=2mm of node-4-3.east] { 00 & 01 & 10 & 11 \\ };

        \scoped[on background layer] {
            \node[fit=(node-4-4-1-1), fill=color-path, inner sep=0pt] {};
            \node[fit=(node-4-4-1-2), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-4-4-1-3), fill=color-node, inner sep=0pt] {};
            \node[fit=(node-4-4-1-4), fill=color-node, inner sep=0pt] {};
        }

        \draw[edge, out=225, in=45] (node-3-3-1-1.south) to (node-4-1.north);
        \draw[edge, out=225, in=45] (node-3-3-1-2.south) to (node-4-2.north);
        \draw[edge, out=315, in=135] (node-3-3-1-3.south) to (node-4-3.north);
        \draw[edge, out=315, in=135] (node-3-3-1-4.south) to (node-4-4.north);

        \matrix[value] (node-5-1) [below = 0mm of node-4-1.south] { a & b & c & d \\ };
        \matrix[value] (node-5-2) [below = 0mm of node-4-2.south] { e & f & g & h \\ };
        \matrix[value] (node-5-3) [below = 0mm of node-4-3.south] { i & j & k & l \\ };
        \matrix[value] (node-5-4) [below = 0mm of node-4-4.south] { m & n & o & p \\ };
    \end{tikzpicture}

    \caption{Visualization of the radix search algorithm}
    \label{fig:rb-tree-example-1}
\end{figure}

\Cref{fig:rb-tree-example-1} is an illustration of how radix search works. There is only a fraction of the tree visualized in the example rendering values in the [92, 107] index range.

The branching factor of the tree is 4, resulting in the subkey size of 2 bits. The mask is equal to 3 or 00000011 in binary representation. For simplicity, the index type is selected to be \emph{unsigned byte} with a maximum capacity of 256.

The tree height in \Cref{fig:rb-tree-example-1} is 4. The goal is to lookup the value at the index 104, which is equal to 01101000\ts{2}. \Cref{lst:rb-tree-radix-search} outlines the radix search algorithm.

The search starts by initializing the node and level variables to root and $height - 1$ correspondingly. The for loop runs until the leaf node level is reached, where each step towards it involves selecting a child node by using bit shifting and masking. After exiting the loop, the function returns the value from the leaf node. The runtime complexity of radix search is \bigo{log_m(n)}.

\begin{listing}[ht!]

    \begin{algorithmic}[1]
        \Function{RadixSearch}{root, key}
            \State node \la\ root

            \For{level \la\ root\ts{height} - 1, 1}
                \State index \la\ (key $\ggg$ (level $\cdot$ x)) \& mask
                \State node \la\ node[index]
            \EndFor

            \State index \la\ key \& mask
            \State \Return {node[index]}
        \EndFunction
    \end{algorithmic}

    \caption{Radix search algorithm}
    \label{lst:rb-tree-radix-search}
\end{listing}

\subsection{Update}
The persistent \emph{update} operation returns a new tree version that includes an updated value, instead of mutating the original instance in-place as with \emph{ephemeral} data structures.

\subsubsection*{Path copying}
When updating a \treerb{}, the radix search algorithm is used to build a path to the value. In order to avoid mutating the original tree instance, each node on the path is copied. This process is called as \emph{path copying} \cite{planar-point-location}. It is important to emphasize that nodes that are not a part of the path are reused.

The update operation performs the \h{} count copies of \m{} sized nodes, where \h{} is the maximum height of the tree. As described in \Cref{eq:h-max}, \h{} is bound by \bigo{log_m(n)}, which results in {\bigo{m \cdot log_m(n)}} complexity of the update operation.

For large branching factors \m{} such as 32, the performance becomes effectively \bigo{1}. For example, if the tree is full, where the count of all elements $n$ is bound by the maximum value of 32 bit integer\footnote{2147483647}, \h{} will be at most 7.

\begin{listing}[ht!]
    \begin{algorithmic}[1]
        \Function{Update}{root, key, value}
            \State newRoot \la\ \Call{Clone}{root}
            \State node \la\ newRoot

            \For{level \la\ root\ts{h} - 1, 1}
                \State index \la\ (key $\ggg$ (level $\cdot$ x)) \& mask
                \State newChildNode \la\ \Call{Clone}{node[index]}
                \State node[index] \la\ newChildNode
                \State node \la\ newChildNode
            \EndFor

            \State index \la\ key \& mask
            \State node[index] \la\ value
            \State \Return newRoot
        \EndFunction
    \end{algorithmic}

    \caption{Path copying algorithm for \treerb{}}
    \label{lst:rb-tree-update}
\end{listing}

From the implementation perspective, the difference between update and radix search is that every visited node, including root, must be copied. The return value is the root node for the new version of the tree.

\subsection{Push}
The push operation is used to add new values to the end of \treerb{}. It employs \emph{path copying} to preserve the original tree without changes. It accepts the root node and new value as arguments and returns a new version of the tree.

The \treerb{} size is used as the search key. For example, if the tree size is 9, a key for the new value will be 9. The size is incremented after the operation completes.

Since the push operation adds new values, it has to manage the tree capacity. Generally, there are two cases that require special handling:

\begin{itemize}
    \item The case when a path to a leaf node includes branches that are not created yet. The solution is to generate missing nodes while descending the tree.
    \item The \emph{root overflow} or when the tree size exceeds its \emph{capacity}\footnote{Capacity is the maximum number of elements a tree can accommodate.}. It can be solved by adding a new level to the tree by creating a new root node and setting the old one as the first child of the new root.
\end{itemize}

The complexity of the operation is \bigo{m \cdot log_m(n)} as it traverses and creates new nodes from the root to a leaf.

\Cref{lst:rb-tree-push} demonstrates how the tree capacity is calculated and managed.

\begin{listing}[ht!]
    \begin{algorithmic}[1]
        \Function{Capacity}{height}
		    \State \Return m $\ll$ ((height - 1) $\cdot$ x)
        \EndFunction

        \State
        
        \Function{Push}{root, value}
            \State newRoot \la\ \nil{}

            \If{\Call{Capacity}{root\ts{height}} <= root\ts{size}}
                \State newRoot \la\ \Call{CreateNode}{}
                \State newRoot[0] \la\ \Call{Clone}{root}
                \State newRoot\ts{height} \la\ root\ts{height} + 1
            \Else
                \State newRoot \la\ \Call{Clone}{root}
            \EndIf

            \State node \la\ newRoot
            \State key \la\ newRoot\ts{size}

            \For{level \la\ newRoot\ts{height} - 1, 1}
                \State index \la\ (key $\ggg$ (level $\cdot$ x)) \& mask

                \State childNode \la\ node[index]
                \State newChildNode \la\ \nil{}

                \If{childNode = \nil{}}
                    \State newChildNode \la\ \Call{CreateNode}{}
                \Else
                    \State newChildNode \la\ \Call{Clone}{childNode}
                \EndIf

                \State node[index] \la\ newChildNode
                \State node \la\ newChildNode
            \EndFor

            \State index \la\ key \& mask
            \State node[index] \la\ value

            \State newRoot\ts{size} \la\ newRoot\ts{size} + 1
            \State \Return newRoot
        \EndFunction
    \end{algorithmic}

    \caption{Pseudocode for the \treerb{}'s push operation}
    \label{lst:rb-tree-push}
\end{listing}

\subsection{Pop}
The purpose of pop is to remove values from the end of \treerb{}. It accepts root as input and returns both a removed value and a new version of a structure.

Pop is responsible for reducing the capacity of \treerb{} when needed, including the removal of empty branches and leaves. Similar to update and push operations, it relies on the path copying algorithm to avoid modifying the existing version of the tree.

\begin{listing}[ht!]

    \begin{algorithmic}[1]
        \Function{PopNode}{node, key}
            \State newNode \la\ \Call{Clone}{node}
            \State value \la\ \nil{}

            \If{node\ts{height} = 0}
                \State index \la\ key \& mask
                \State value \la\ newNode[index]
                \State newNode[index] \la\ \nil{}
            \Else
                \State index \la\ (key $\ggg$ (newNode\ts{height} $\cdot$ x)) \& mask
                \State value, childNode \la\ \Call{PopNode}{newNode[index], key}
                \State newNode[index] \la\ childNode
            \EndIf

            \If{newNode[0] = \nil{}}
                \State \Return value, \nil{}
            \Else
                \State \Return value, newNode
            \EndIf
        \EndFunction

        \State

        \Function{Pop}{root}
            \State value, newRoot \la\ \Call{PopNode}{root, root\ts{size} - 1}

            \If{newRoot[1] = \nil{})}
                \State newRoot \la\ newRoot[0]
            \EndIf

            \State \Return value, newRoot
        \EndFunction
    \end{algorithmic}

    \caption{Pseudocode for the \treerb{}'s pop operation}
    \label{lst:rb-tree-pop}
\end{listing}

Since \treerb{} is a complete\footnote{A complete \m{}-ary tree is an \m{}-ary tree, which is maximally space-efficient. It must be filled on every level except for the last level. However, if the last level is not complete, all nodes of the tree must be "as far left as possible".} tree, all entries to the right of \nil{} must be absent as well. As shown in \Cref{lst:rb-tree-pop}, checking if the first entry is \nil{} is sufficient to understand if a node must be removed. If it is true, the empty child will be replaced with a \nil{} reference in the parent node.

A root is redundant if it contains only a single child node, which is true if the second entry is \nil{}.  The original root is \emph{demoted} by replacing it with the first child node, which becomes the new root.

The pop operation involves tree traversal, and it is creating \m{} new nodes. Hence, its complexity is \bigo{m \cdot log_m(n)}.

\section{Relaxed radix balanced tree}
\label{sec:rrb-tree}

Relaxed radix balanced tree or \treerrb{}, extends \treerb{} to support concatenation and splitting in \bigo{log(n)} rather than linear time without compromising the performance of other operations.

An invariant that \treerb{} maintains is that all nodes except the right-most ones have to be full. This enables a simple radix search implementation, but on the other hand, makes efficient sub-linear concatenation impossible.

The \treerrb{} relaxes this constraint by allowing nodes to be partially full, and introduces a rebalancing algorithm to ensure that the tree height does not exceed the \bigo{log(n)} bound to keep performance guarantees for other operations.

In this section, we will look at how \treerrb{} works, specifically the concatenation algorithm and the relaxed variant of the radix search. For details of the implementation of the split, relaxed push, and pop operations, please refer to the project source code\footnote{\url{https://github.com/arazabishov/pvec-rs}} or to \cite{improving-performance-through-transience}.

\subsection{Relaxed radix search}
With relaxed \treerrb{} constraints, there is no reliable way to calculate the size of the subtree without additional metadata. Hence, the \emph{sizes} array is introduced to keep track of the subtree size. The \emph{sizes} array is \m{} elements long, where each value represents the subtree size at the corresponding index. The sizes table values are re-calculated when the subtree is modified, for example, when concatenating or pushing new values.

When the radix search encounters a relaxed node, it compares the entire search key against entries in the size table. A subtree contains the desired value if the corresponding size table entry is bigger than or equal to the search key. Before descending into a subtree and repeating the search step, the search key is subtracted the size of the subtree.

When a balanced node is encountered, the search process falls back to the balanced version of the radix search algorithm \Cref{sec:rb-tree-radix-search}. 

Since the tree traversal involves scanning an \m{} long \emph{sizes} array for every node from the root to a leaf, the complexity of relaxed radix search is \bigo{m \cdot log_m(n)}. In theory, the \textproc{FindIndex} function in \Cref{lst:rrb-tree-relaxed-radix-search} can be replaced with binary search resulting in slightly better \bigo{log_2(m) \cdot log_m(n)} performance. However, it is nearly impossible to measure the difference for such small sized arrays, as linear scan can be as fast if not faster due to its simplicity and CPU cache locality\footnote{\url{https://dirtyhandscoding.wordpress.com/2017/08/25/performance-comparison-linear-search-vs-binary-search/}}.

\begin{listing}[!ht]

    \begin{algorithmic}[1]
        \Function{FindIndex}{sizes, idx}
            \State candidate \la 0

            \If{candidate < \m\ - 1 \And\ sizes[candidate] <= idx}
                \State candidate++
            \EndIf

            \State \Return candidate
        \EndFunction

        \State

        \Function{RelaxedRadixSearch}{root, key}
            \State node \la\ root
            \State idx \la\ key

            \For{level \la\ root\ts{height} - 1, 1}
                \If{node\ts{sizes} = \nil{}}
                    \State index \la\ (key $\ggg$ (level $\cdot$ x)) \& mask
                    \State node \la\ node[index]
                \Else
                    \State sizes \la\ node\ts{sizes}
                    \State index \la\ \Call{FindIndex}{sizes, idx}
                    \State node \la\ node[index]

                    \If{index != 0}
                        \State idx \la\ idx - sizes[index - 1]
                    \EndIf
                \EndIf
            \EndFor

            \State index \la\ idx \& mask
            \State \Return {node[index]}
        \EndFunction
    \end{algorithmic}

    \caption{Pseudocode of relaxed radix search}
    \label{lst:rrb-tree-relaxed-radix-search}
\end{listing}

\subsection{Concatenation}
The concatenation algorithm used in this project is from \cite{rrb-vector-practical-general-purpose-im-sequence}, which produces a slightly more balanced tree than initially proposed by \cite{efficient-immutable-vectors}. It achieves it by allowing the relaxed tree nodes to have \m{} children instead of $\m{} - 1$.

The algorithm consists of two stages: descending the tree, and then, merging and rebalancing nodes. The time complexity of the presented concatenation algorithm is \bigo{m^2 \cdot{} log_m(n)}.

The recursive function in Listing \ref{lst:rrb-tree-concatenation} descends the tree by selecting the rightmost node of the left tree and the leftmost node of the right tree. If one of the trees is taller than the other, the function descends into a taller tree only until nodes of both trees are at the same level.

When the bottom level with leaf nodes is reached, the function stops descending and starts merging and rebalancing nodes to ensure the \bigo{log_m(n)} bound on the tree height.

\begin{listing}[!ht]
    \begin{algorithmic}[1]
        \Function{Concat}{leftNode, rightNode}
            \If{leftNode\ts{height} > rightNode\ts{height}}
                \State mergedNode \la\ \Call{Concat}{leftNode\ts{last}, rightNode}
                \State \Return \Call{Rebalance}{leftNode\ts{init}, mergedNode, \nil{}}
            \ElsIf{leftNode\ts{height} < rightNode\ts{height}}
                \State mergedNode \la\ \Call{Concat}{leftNode, rightNode\ts{first}}
                \State \Return \Call{Rebalance}{\nil{}, mergedNode, rightNode\ts{tail}}
            \Else
                \State mergedNode \la\ \nil{}

                \If{leftNode\ts{height} = 0}
                    \State mergedNode \la\ \Call{Concat}{leftNode, rightNode}
                \Else
                    \If{leftNode\ts{height} = 1}
                        \State mergedNode \la\ \Call{Concat}{leftNode\ts{last}, rightNode\ts{first}}
                    \Else
                        \State mergedNode \la\ \Call{Concat}{leftNode\ts{last}, rightNode\ts{first}}
                    \EndIf
                \EndIf

                \State \Return \Call{Rebalance}{leftNode\ts{init}, mergedNode, rightNode\ts{tail}}
            \EndIf
        \EndFunction
    \end{algorithmic}

    \caption{Concatenation algorithm of \treerrb{}}
    \label{lst:rrb-tree-concatenation}
\end{listing}

The \textproc{Rebalance} function accepts three lists of nodes as arguments. The left and right lists constitute all nodes of both trees at the given level except two: the rightmost node of the left tree and the leftmost node of the right tree. Those two nodes are already rebalanced and passed as the middle argument. Three lists are concatenated together into a single merged list.

The goal of rebalancing is to arrange the children of merged nodes in such a way that all nodes except the rightmost branch are filled with values. When the \textproc{Rebalance} function completes re-arranging nodes, it returns a new branch containing rebalanced nodes. Pseudocode for rebalancing can be found in Appendix \ref{lst:rrb-tree-rebalance}.

The rebalancing process is illustrated in Figures \ref{fig:rrb-tree-rebalance-level-0}-\ref{fig:rrb-tree-rebalance}. Note, presented figures exclude parts of trees that are not important for conveying the idea to preserve space.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colorleft] (left-1-1) at (current page.north west) { & & & \\ };

        \matrix[node, fill=colorleft] (left-2-4) [below right=8mm and 1mm of left-1-1.south] { & & \\ };
        \node (left-2-3) [left=2mm of left-2-4.west] { \ldots };
        \node (left-2-2) [left=2mm of left-2-3.west] { \ldots };
        \node (left-2-1) [left=2mm of left-2-2.west] { \ldots };

        \draw[edge-dashed, out=225, in=45] (left-1-1-1-1.south) to (left-2-1.north);
        \draw[edge-dashed, out=225, in=45] (left-1-1-1-2.south) to (left-2-2.north);
        \draw[edge-dashed, out=225, in=75] (left-1-1-1-3.south) to (left-2-3.north);
        \draw[edge, out=315, in=90] (left-1-1-1-4.south) to (left-2-4.north);

        \matrix[node, fill=colorleft] (left-3-2) [below left=8mm and 1mm of left-2-4.south] { e & f & g & h \\ };
        \matrix[node, fill=colorleft] (left-3-3) [below right=8mm and 1mm of left-2-4.south] { i & j \\ };
        \matrix[node, fill=colorleft] (left-3-1) [left=2mm of left-3-2.west] { a & b & c & d \\ };

        \draw[edge, out=225, in=45] (left-2-4-1-1.south) to (left-3-1.north);
        \draw[edge, out=225, in=45] (left-2-4-1-2.south) to (left-3-2.north);
        \draw[edge, out=315, in=90] (left-2-4-1-3.south) to (left-3-3.north);

        \matrix[node, fill=colorright] (right-1-1) [right=56mm of left-1-1.east] { & \\ };
        \matrix[node, fill=colorright] (right-2-1) [below left=8mm and 1mm of right-1-1.south] { & & & \\ };
        \node (right-2-2) [right=2mm of right-2-1.east] { \ldots };

        \draw[edge, out=225, in=90] (right-1-1-1-1.south) to (right-2-1.north);
        \draw[edge-dashed, out=315, in=90] (right-1-1-1-2.south) to (right-2-2.north);

        \matrix[node, fill=colorright] (right-3-2) [below left=8mm and 1mm of right-2-1.south] { o & p & q & r \\ };
        \matrix[node, fill=colorright] (right-3-3) [below right=8mm and 1mm of right-2-1.south] { s & t & u & v \\ };
        \matrix[node, fill=colorright] (right-3-1) [left=2mm of right-3-2.west] { k & l & m & n \\ };
        \matrix[node, fill=colorright] (right-3-4) [right=2mm of right-3-3.east] { w & x & y & z \\ };

        \draw[edge, out=225, in=45] (right-2-1-1-1.south) to (right-3-1.north);
        \draw[edge, out=225, in=45] (right-2-1-1-2.south) to (right-3-2.north);
        \draw[edge, out=315, in=135] (right-2-1-1-3.south) to (right-3-3.north);
        \draw[edge, out=315, in=135] (right-2-1-1-4.south) to (right-3-4.north);

        \node[draw, dashed, inner sep=1mm, fit=(left-3-3) (left-3-3) (right-3-1) (left-3-3)] {};
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm at level 0}
    \label{fig:rrb-tree-rebalance-level-0}
\end{figure}

Concatenation starts at the bottom of the tree by merging the leaf nodes. The result is a new rebalanced branch with leaves that will be used when rebalancing nodes at level 1.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}
    \colorlet{colormerged}{orange!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colorleft] (left-1-1) at (current page.north west) { & & & \\ };

        \matrix[node, fill=colorleft] (left-2-4) [below right=8mm and 1mm of left-1-1.south] { & \\ };
        \node (left-2-3) [left=2mm of left-2-4.west] { \ldots };
        \node (left-2-2) [left=2mm of left-2-3.west] { \ldots };
        \node (left-2-1) [left=2mm of left-2-2.west] { \ldots };

        \draw[edge-dashed, out=225, in=45] (left-1-1-1-1.south) to (left-2-1.north);
        \draw[edge-dashed, out=225, in=45] (left-1-1-1-2.south) to (left-2-2.north);
        \draw[edge-dashed, out=225, in=75] (left-1-1-1-3.south) to (left-2-3.north);
        \draw[edge, out=315, in=90] (left-1-1-1-4.south) to (left-2-4.north);

        \matrix[node, fill=colorleft] (left-3-2) [below right=8mm and 1mm of left-2-4.south] { e & f & g & h \\ };
        \matrix[node, fill=colorleft] (left-3-1) [left=2mm of left-3-2.west] { a & b & c & d \\ };

        \draw[edge, out=225, in=45] (left-2-4-1-1.south) to (left-3-1.north);
        \draw[edge, out=315, in=90] (left-2-4-1-2.south) to (left-3-2.north);

        \matrix[node, fill=colormerged] (merged-1-1) [right=32mm of left-2-4.east] { & \\ };
        \matrix[node, fill=colormerged] (merged-2-1) [below left=8mm and 1mm of merged-1-1.south] { i & j & k & l \\ };
        \matrix[node, fill=colormerged] (merged-2-2) [below right=8mm and 1mm of merged-1-1.south] { m & n \\ };

        \draw[edge, out=225, in=90] (merged-1-1-1-1.south) to (merged-2-1.north);
        \draw[edge, out=315, in=90] (merged-1-1-1-2.south) to (merged-2-2.north);

        \matrix[node, fill=colorright] (right-1-1) [right=72mm of left-1-1.east] { & \\ };
        \matrix[node, fill=colorright] (right-2-1) [below left=8mm and 1mm of right-1-1.south] { & & \\ };
        \node (right-2-2) [right=2mm of right-2-1.east] { \ldots };

        \draw[edge, out=225, in=90] (right-1-1-1-1.south) to (right-2-1.north);
        \draw[edge-dashed, out=315, in=90] (right-1-1-1-2.south) to (right-2-2.north);

        \matrix[node, fill=colorright] (right-3-1) [below left=8mm and 1mm of right-2-1.south] { o & p & q & r \\ };
        \matrix[node, fill=colorright] (right-3-2) [right=2mm of right-3-1.east] { s & t & u & v \\ };
        \matrix[node, fill=colorright] (right-3-3) [right=2mm of right-3-2.east] { w & x & y & z \\ };

        \draw[edge, out=225, in=45] (right-2-1-1-1.south) to (right-3-1.north);
        \draw[edge, out=315, in=135] (right-2-1-1-2.south) to (right-3-2.north);
        \draw[edge, out=315, in=135] (right-2-1-1-3.south) to (right-3-3.north);

        \node[draw, dashed, inner sep=1mm, fit=(merged-1-1) (merged-1-1) (left-2-4) (right-2-1)] {};
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm at level 1}
    \label{fig:rrb-tree-rebalance-level-1}
\end{figure}

Rebalancing at level 1 involves the left and right branches together with the newly created branch from the previous step. The algorithm avoids processing nodes where rebalancing is not beneficial. For example, in Figure \ref{fig:rrb-tree-rebalance-level-2} where the \emph{full} nodes from the left-hand side tree are re-used without rebalancing them.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}
    \colorlet{colormerged}{orange!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colorleft] (left-1-1) at (current page.north west) { & & \\ };

        \node (left-2-3) [left=2mm of left-2-4.west] { \ldots };
        \node (left-2-2) [left=2mm of left-2-3.west] { \ldots };
        \node (left-2-1) [left=2mm of left-2-2.west] { \ldots };

        \draw[edge-dashed, out=225, in=45] (left-1-1-1-1.south) to (left-2-1.north);
        \draw[edge-dashed, out=225, in=45] (left-1-1-1-2.south) to (left-2-2.north);
        \draw[edge-dashed, out=225, in=75] (left-1-1-1-3.south) to (left-2-3.north);

        \matrix[node, fill=colormerged] (merged-1-1) [right=38mm of left-1-1.east] { & \\ };
        \matrix[node] (merged-2-1) [below left=8mm and 22mm of merged-1-1.south] { & & & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-2-1-1-1), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-2), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-3), fill=colormerged, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-4), fill=colormerged, inner sep=0pt] {};
        }

        \matrix[node, fill=colormerged] (merged-2-2) [below right=8mm and 22mm of merged-1-1.south] { & & \\ };

        \matrix[node, fill=colorleft] (merged-3-2) [below left=8mm and 1mm of merged-2-1.south] { e & f & g & h \\ };
        \matrix[node, fill=colormerged] (merged-3-3) [below right=8mm and 1mm of merged-2-1.south] { i & j & k & l \\ };
        \matrix[node, fill=colorleft] (merged-3-1) [left=2mm of merged-3-2.west] { a & b & c & d \\ };
        \matrix[node, fill=colormerged] (merged-3-4) [right=2mm of merged-3-3.east] { m & n & o & p \\ };

        \draw[edge, out=225, in=45] (merged-2-1-1-1.south) to (merged-3-1.north);
        \draw[edge, out=225, in=45] (merged-2-1-1-2.south) to (merged-3-2.north);
        \draw[edge, out=315, in=135] (merged-2-1-1-3.south) to (merged-3-3.north);
        \draw[edge, out=315, in=135] (merged-2-1-1-4.south) to (merged-3-4.north);

        \matrix[node, fill=colormerged] (merged-3-6) [below right=8mm and 1mm of merged-2-2.south] { u & v & w & x \\ };
        \matrix[node, fill=colormerged] (merged-3-7) [right=2mm of merged-3-6.east] { y & z \\ };
        \matrix[node, fill=colormerged] (merged-3-5) [left=2mm of merged-3-6.west] { q & r & s & t \\ };

        \draw[edge, out=225, in=90] (merged-1-1-1-1.south) to (merged-2-1.north);
        \draw[edge, out=315, in=90] (merged-1-1-1-2.south) to (merged-2-2.north);

        \draw[edge, out=225, in=45] (merged-2-2-1-1.south) to (merged-3-5.north);
        \draw[edge, out=315, in=135] (merged-2-2-1-2.south) to (merged-3-6.north);
        \draw[edge, out=315, in=135] (merged-2-2-1-3.south) to (merged-3-7.north);

        \matrix[node, fill=colorright] (right-1-1) [right=38mm of merged-1-1.east] { \\ };
        \node (right-2-2) [below right=8mm and 1mm of right-1-1.south] { \ldots };

        \draw[edge-dashed, out=315, in=90] (right-1-1-1-1.south) to (right-2-2.north);

        \node[draw, dashed, inner sep=1mm, fit=(merged-1-1) (merged-1-1) (left-1-1) (right-1-1)] {};
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm at level 2}
    \label{fig:rrb-tree-rebalance-level-2}
\end{figure}

Figure \ref{fig:rrb-tree-rebalance} is the last step that rebalances the top-level nodes of the left and right trees, producing a new root. If the root contains only a single child, its child will be promoted to be the root to avoid unnecessary overhead.

\begin{figure}[H]
    \colorlet{colorleft}{red!30}
    \colorlet{colorright}{yellow!30}
    \colorlet{colormerged}{orange!30}

    \centering
    \footnotesize
    \begin{tikzpicture} [
        node/.style={
            matrix of nodes,
            nodes={draw,minimum width=4mm,minimum height=5mm,anchor=center},
            inner sep=0pt,
            font=\ttfamily,
            text height=1.5ex,
            text width=1.5ex,
            text centered,
            nodes in empty cells
        },
        edge/.style={->, shorten >= 4pt},
        edge-dashed/.style={dashed, ->, shorten >= 4pt},
    ]
        \matrix[node, fill=colormerged] (root) at (current page.north) { & \\ };

        \matrix[node] (merged-1-1) [below left=8mm and 8mm of root.south] { & & & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-1-1-1-1), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-1-1-1-2), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-1-1-1-3), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-1-1-1-4), fill=colormerged, inner sep=0pt] {};
        }

        \matrix[node] (merged-1-2) [below right=8mm and 8mm of root.south] { & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-1-2-1-1), fill=colormerged, inner sep=0pt] {};
            \node[fit=(merged-1-2-1-2), fill=colorright, inner sep=0pt] {};
        }

        \draw[edge, out=270, in=75] (root-1-1.south) to (merged-1-1.north);
        \draw[edge, out=270, in=115] (root-1-2.south) to (merged-1-2.north);

        \matrix[node] (merged-2-1) [below left=8mm and 1mm of merged-1-1.south] { & & & \\ };
        \scoped[on background layer] {
            \node[fit=(merged-2-1-1-1), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-2), fill=colorleft, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-3), fill=colormerged, inner sep=0pt] {};
            \node[fit=(merged-2-1-1-4), fill=colormerged, inner sep=0pt] {};
        }

        \matrix[node, fill=colormerged] (merged-2-2) [below=8mm of merged-1-2.south] { & & \\ };

        \node (merged-left-3) [left=2mm of merged-2-1.west] { \ldots };
        \node (merged-left-2) [left=2mm of merged-left-3.west] { \ldots };
        \node (merged-left-1) [left=2mm of merged-left-2.west] { \ldots };

        \draw[edge-dashed, out=205, in=75] (merged-1-1-1-1.south) to (merged-left-1.north);
        \draw[edge-dashed, out=205, in=55] (merged-1-1-1-2.south) to (merged-left-2.north);
        \draw[edge-dashed, out=205, in=45] (merged-1-1-1-3.south) to (merged-left-3.north);

        \node (merged-right-1) [right=2mm of merged-2-2.east] { \ldots };
        \draw[edge-dashed, out=315, in=105] (merged-1-2-1-2.south) to (merged-right-1.north);

        \matrix[node, fill=colorleft] (merged-3-2) [below left=8mm and 10mm of merged-2-1.south] { e & f & g & h \\ };
        \matrix[node, fill=colormerged] (merged-3-3) [below=8mm of merged-2-1.south] { i & j & k & l \\ };
        \matrix[node, fill=colorleft] (merged-3-1) [left=2mm of merged-3-2.west] { a & b & c & d \\ };
        \matrix[node, fill=colormerged] (merged-3-4) [right=2mm of merged-3-3.east] { m & n & o & p \\ };

        \draw[edge, out=205, in=45] (merged-2-1-1-1.south) to (merged-3-1.north);
        \draw[edge, out=205, in=45] (merged-2-1-1-2.south) to (merged-3-2.north);
        \draw[edge, out=270, in=90] (merged-2-1-1-3.south) to (merged-3-3.north);
        \draw[edge, out=270, in=90] (merged-2-1-1-4.south) to (merged-3-4.north);

        \matrix[node, fill=colormerged] (merged-3-5) [below=8mm of merged-2-2.south] { q & r & s & t \\ };
        \matrix[node, fill=colormerged] (merged-3-6) [right=2mm of merged-3-5.east] { u & v & w & x \\ };
        \matrix[node, fill=colormerged] (merged-3-7) [right=2mm of merged-3-6.east] { y & z \\ };

        \draw[edge, out=225, in=90] (merged-1-1-1-4.south) to (merged-2-1.north);
        \draw[edge, out=315, in=90] (merged-1-2-1-1.south) to (merged-2-2.north);

        \draw[edge, out=270, in=90] (merged-2-2-1-1.south) to (merged-3-5.north);
        \draw[edge, out=270, in=135] (merged-2-2-1-2.south) to (merged-3-6.north);
        \draw[edge, out=315, in=135] (merged-2-2-1-3.south) to (merged-3-7.north);
    \end{tikzpicture}

    \caption{Illustration of rebalancing algorithm: a rebalanced tree}
    \label{fig:rrb-tree-rebalance}
\end{figure}

The formal description and analysis of concatenation algorithm and its implementation is thoroughly presented in \cite{improving-performance-through-transience}.

\section{Transience}
\label{sec:transience}

When modified, conventional persistent data structures always return a new version that includes the change. It is a reliable and straightforward way to ensure that existing versions are not changed, a behavior that is essential to robust programs.

However, there are scenarios when persistence is not useful, such as when working with a collection in isolated environment like a pure function. For example, building a new vector using the \emph{push} operation creates a new version on every call, immediately dismissing the previous one.

Even though persistent data structures minimize the cost of creating new versions by \emph{path copying}, memory allocations are still very resource consuming. Thus, \emph{transient} data types were introduced to the Clojure programming language to solve this problem.

\emph{Transience} is an optimization that allows us to update persistent data structures in place without creating new versions in performance-critical code. Once a transient data structure is constructed, it can be converted back to persistent and safely shared.

\begin{listing}[!ht]

    \centering
    \begin{minted}[
        fontsize=\small,
        stripnl=false,
        framesep=4mm,
        frame=lines,
        autogobble,
        linenos
    ]{clojure}
    (defn vecpersistent [n]             ;; uses a persistent vector
        (loop [i 0 v []]
            (if (< i n)
            (recur (inc i) (conj v i))
            v)))

    (defn vectransient [n]              ;; uses a transient vector
        (loop [i 0 v (transient [])]
            (if (< i n)
            (recur (inc i) (conj! v i))
            (persistent! v))))
    \end{minted}

    \caption{An example of working with transient and persistent vectors in Clojure}
    \label{lst:clojure-vector-example}
\end{listing}

As demonstrated in \Cref{lst:clojure-vector-example}, working with transient types requires special syntax such as \mintinline{clojure}{transient}, \mintinline{clojure}{conj!}, and \mintinline{clojure}{persistent}\footnote{\url{https://clojure.org/reference/transients}}.

\subsection{Guarantees and limitations}
Clojure ensures that transients do not violate the guarantees of persistent data structures by enforcing the following rules:
\begin{itemize}
    \item A transient vector created from a persistent one does not modify the original version. The cost of creating a transient instance is \bigo{1}, as well as transforming it back to persistent.
    \item Transients are confined to the thread they are created on, effectively forbidding sharing between threads and eliminating the possibility of race conditions.
    \item Transients are not allowed to be used after converting them back to persistent to avoid in-directly modifying a persistent version.
\end{itemize}
